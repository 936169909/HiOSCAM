#include "globals.h"
#ifdef READER_NAGRA
#include "cscrypt/bn.h"
#include "cscrypt/idea.h"
#include "oscam-time.h"
#include "reader-common.h"
#include "oscam-work.h"

struct nagra_data {
	IDEA_KEY_SCHEDULE ksSession;
	int8_t			is_pure_nagra;
	int8_t			is_tiger;
	int8_t			is_n3_na;
	int8_t			has_dt08;
	int8_t			swapCW;
	uint8_t			ExpiryDate[2];
	uint8_t			ActivationDate[2];
	uint8_t			plainDT08RSA[64];
	uint8_t			IdeaCamKey[16];
	uint8_t			sessi[16];
	uint8_t			signature[8];
	uint8_t			cam_state[3];
};
// sky()
// boxKey_Tigers
//	0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
static  uint8_t	rsaMod_Tigers[120] = {
	0xA9,0x2D,0xA7,0x2F,0xEE,0xAC,0xF2,0x94,0x7B,0x00,0x3E,0xD6,0x52,0x15,0x3B,0x18,
	0x9E,0x40,0x43,0xB0,0x13,0x8C,0x36,0x8B,0xDF,0x6B,0x9E,0xD7,0x7D,0xDA,0xD6,0xC0,
	0x76,0x1A,0x21,0x98,0xAE,0xB3,0xFC,0x97,0xA1,0x9C,0x9D,0x01,0xCA,0x76,0x9B,0x3F,
	0xFF,0xE4,0xF6,0xE7,0x0F,0xA4,0xE0,0x69,0x6A,0x89,0x80,0xE1,0x8D,0x8C,0x58,0xE1,
	0x1D,0x81,0x71,0x21,0x34,0x6E,0x3E,0x66,0x45,0x7F,0xDD,0x84,0xCF,0xA7,0x25,0x89,
	0xB2,0x5B,0x53,0x8E,0xFC,0x30,0x43,0x61,0xB5,0x48,0x45,0xF3,0x9E,0x9E,0xFA,0x52,
	0xD8,0x05,0xE5,0xFD,0x86,0xB5,0x95,0xB3,0x66,0xC3,0x57,0x16,0xAB,0xC9,0x1F,0xA3,
	0xDC,0x15,0x9C,0x9F,0x4D,0x81,0x64,0xB5,
};

//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//
//
// sky()
//	#define __simulation_ukcable__
//
//
#if defined(__simulation_ukcable__)
	#define __UK_CABLE__
//	#define __EPCS_SOURCE_BOX__
//	#define __BRAZIL__

	#define UKCABLE_DATALENN	(4+8+64)	// irdid(4),boxkey(signature)(8),rsakey(64)

	static uint8_t	ukcable_dt08_natives[][UKCABLE_DATALENN] = {
			#if defined(__BRAZIL__)
				{	0x61,0x1E,0x1E,0xFE,
					0x0E,0x5C,0x0A,0xDB,0x94,0x31,0x47,0x6A,
					0xD3,0x65,0xAF,0xF9,0x7D,0x08,0x05,0x38,0x02,0xC5,0xBC,0x3E,0x78,0x5A,0xC8,0x59,
					0x34,0x80,0x4C,0x06,0x09,0x97,0xB8,0x1B,0x18,0x42,0xE7,0x3C,0xA8,0x13,0x7B,0x82,
					0x79,0x58,0x23,0x83,0x63,0x0F,0x25,0x9E,0x9E,0x6B,0x7A,0x6C,0x7A,0xE1,0x96,0xA5,
					0x9F,0xA1,0xD4,0x8A,0xEB,0x1B,0x6D,0x05,0x93,0x68,0x0A,0xF6,0xCC,0x9C,0x95,0x6B,
				},
				{	0x63,0x6F,0xDB,0xD7,
					0x52,0xE9,0xA0,0x5F,0xC4,0xFB,0xBD,0x1B,
					0x89,0x8E,0xC5,0xD0,0x22,0xB2,0x96,0x3C,0x5F,0x7C,0x39,0x23,0xBE,0xCF,0xB2,0x3B,
					0x9A,0xBB,0x3B,0xF8,0x81,0x3E,0xD3,0x35,0x2C,0x9A,0x92,0x1A,0x78,0x96,0xCC,0xE6,
					0xB4,0x55,0x67,0x21,0x61,0x29,0x68,0xE9,0x65,0x0E,0x16,0xC2,0x2B,0x52,0xAC,0xF5,
					0x06,0x1E,0x6B,0x5E,0x9E,0xC8,0xDE,0x48,0x79,0x8B,0x13,0x86,0x91,0x11,0xF8,0x67,
				},
				{	0x61,0x18,0xEC,0xF4,
					0xA7,0x3F,0x03,0x0D,0x00,0xF1,0x54,0xD6,
					0xA9,0xB7,0xD4,0x7F,0x9A,0x8D,0x59,0xCB,0xF4,0xDE,0x4F,0x78,0x89,0x0D,0xD6,0x8E,
					0x50,0x3E,0x94,0x12,0xA1,0x03,0xAD,0x42,0xE2,0xF2,0xD9,0x8B,0x7B,0x5E,0x2F,0x1F,
					0x24,0xB3,0xF8,0xBE,0x11,0xD7,0x04,0x26,0x62,0x4C,0x66,0x33,0x87,0x4F,0x50,0x4E,
					0x73,0x6D,0x13,0x28,0xA1,0xB7,0x8B,0xBC,0x45,0x44,0xB8,0x04,0x6E,0xBF,0xC1,0x99,
				},
				{	0x61,0x16,0x4F,0xF9,
					0x45,0xB0,0xA7,0x20,0x74,0xCF,0x7B,0x69,
					0x94,0x8A,0xFB,0x14,0x5C,0x59,0x68,0x73,0x6C,0x94,0x38,0xBA,0x91,0x08,0x15,0x58,
					0x5D,0x58,0x3F,0x60,0x03,0xB0,0x30,0xB7,0x80,0x99,0x3C,0x29,0xBD,0x99,0x5E,0x74,
					0x92,0xF1,0x38,0x35,0xD9,0xF1,0xE7,0x72,0x65,0x49,0x53,0x24,0x7D,0xEE,0x5E,0xE6,
					0xAD,0x9A,0xBF,0x94,0xBF,0xD2,0x53,0x45,0x19,0x89,0x92,0xBB,0x14,0xFA,0xCE,0x7B,
				},
				{	0x64,0x67,0x72,0xFF,	//Embratel
					0x9D,0x87,0x4C,0x29,0xDA,0xA1,0x2D,0x53,
					0xE6,0xDA,0xA7,0x8A,0x57,0x87,0x56,0x18,0xBD,0x41,0x7C,0x0E,0xF6,0x9E,0x2E,0xD8,
					0xB9,0x4E,0x6E,0x1B,0x37,0x71,0x77,0x26,0x7F,0x47,0x22,0x24,0xBF,0x17,0x2B,0x37,
					0x8B,0x31,0x32,0x43,0x2F,0xF3,0x0E,0x5B,0x1C,0x32,0x5E,0x2E,0x5F,0xB3,0x39,0x51,
					0x9D,0xD4,0x05,0x53,0x7B,0xFB,0x95,0x12,0x1F,0x0B,0x77,0xA6,0x8B,0x7B,0x56,0x1B,
				},
				{	0x64,0x66,0xB3,0xE8,	//Embratel
					0x54,0x48,0xDD,0x34,0xDD,0x79,0x01,0x1F,
					0x86,0x13,0xCD,0x01,0xF0,0xF3,0x10,0xA8,0xB2,0x12,0xC3,0xB3,0x20,0x27,0xD1,0xAD,
					0x2F,0xF1,0x72,0x50,0x52,0xBC,0x15,0x54,0xBD,0x10,0x68,0xC5,0xA6,0x1D,0x5D,0x15,
					0x7D,0x28,0xC2,0xCB,0xE5,0x22,0x7E,0x5F,0x88,0x71,0xBD,0x59,0x08,0xEE,0x64,0xE6,
					0x3C,0x00,0x50,0x24,0x9E,0x6D,0xF6,0x93,0x45,0xA7,0x96,0x33,0xDB,0xAB,0x3A,0x93
				},
			#endif
			#if defined(__UK_CABLE__)
				// BATA:ok
				{	0x66,0xBD,0x68,0x81,
					0x3E,0x13,0x2F,0x62,0x23,0x6A,0x0F,0xDF,
					0x90,0x72,0xE1,0x57,0x2C,0x3A,0x2A,0x6C,0xA0,0xE3,0x25,0xA6,0x47,0xD6,0x8D,0x39,
					0xFD,0x35,0x67,0x98,0x2C,0x80,0x95,0x83,0x4B,0x04,0x16,0xF1,0x06,0xD2,0x50,0x1E,
					0x54,0xD1,0x62,0x36,0xFF,0x28,0x83,0x56,0x84,0x4A,0xB4,0xCA,0xA7,0x46,0xDD,0xDF,
					0x58,0x91,0xAB,0x4C,0xF7,0x9D,0xB7,0xEF,0xAF,0xB2,0x91,0xFE,0x68,0x3C,0x4B,0x41,
				},
			/*
				// VSTVcard
				{	0x66,0xA1,0xDC,0xA4,
					0x37,0x93,0x7D,0xE0,0xF0,0x97,0x67,0x37,
					0xB1,0x23,0xA1,0x2F,0x8B,0x84,0xC4,0x2B,0x64,0x97,0x23,0xC9,0x27,0xA0,0xFC,0x40,
					0xDA,0x4A,0xD3,0x85,0x38,0xEC,0xA1,0x5C,0xC1,0xE0,0x38,0xBD,0xB6,0xEF,0x91,0x5F,
					0x22,0x57,0x8B,0xF9,0xED,0x2A,0xAA,0x51,0xA7,0x7B,0xF7,0xDD,0xC1,0x3B,0xD8,0x54,
					0xD1,0x4A,0x4B,0xA6,0xAC,0xE9,0xC1,0xE5,0xE7,0x3E630xCC,0x3F,0xC1,0x4C,0xE7,0x21,0x65,
				},
			*/
				{	0x3E,0x6E,0x9C,0x2A,
					0xB5,0xF9,0x8C,0xC5,0x02,0x20,0xA7,0x03,
					0x8A,0x33,0xC9,0xBA,0x20,0xFC,0x09,0x19,0x3A,0x60,0x0C,0x5B,0xEB,0xCF,0xB2,0x54,
					0x71,0xDD,0x56,0xEF,0x76,0x40,0x05,0xFE,0x60,0xC4,0x84,0x49,0x12,0xED,0xD1,0x8F,
					0x37,0x51,0x27,0x0E,0xE0,0x83,0x42,0x7E,0x79,0x9C,0x92,0x7F,0xD8,0x96,0xE9,0x7D,
					0xF3,0xF9,0x40,0x0E,0x11,0xEC,0xDD,0x58,0x7E,0xCA,0x90,0x38,0x69,0xC6,0xFF,0xCF,
				},
				#ifdef __EPCS_SOURCE_BOX__
				{	0x63,0xBC,0x70,0x9D,
					0xEE,0x0F,0xF7,0x78,0x66,0xFE,0x9F,0xE6,
					0xA0,0x1B,0xB1,0xDC,0xD0,0x5D,0x36,0xFE,0xEB,0x05,0x97,0x6C,0x43,0x27,0x5A,0x0A,
					0xC3,0xE4,0xC3,0x20,0x01,0xCD,0xC7,0xEF,0xBA,0x6E,0x95,0x91,0x10,0x80,0x7E,0xFC,
					0x25,0x42,0x6A,0x47,0xA0,0x60,0x79,0xCA,0x43,0x58,0x0D,0x40,0xB7,0x82,0xF9,0xCC,
					0xAC,0x6C,0xD1,0x02,0x3F,0x03,0xAB,0x72,0x4B,0x66,0x75,0x22,0x7F,0x24,0xE5,0x15,
				},
				{	0x3E,0x68,0xD7,0x01,
					0x5E,0xB7,0x6F,0xAC,0x63,0xB1,0x0E,0xEE,
					0xC9,0x6E,0x0D,0x24,0xF1,0xB3,0x58,0x15,0x66,0x08,0x2E,0x6B,0xC1,0xFA,0x40,0x26,
					0x16,0xCC,0xD8,0x87,0x83,0x59,0x6D,0xAB,0xA0,0xFE,0x26,0x05,0x6D,0xBC,0xAE,0x17,
					0x7A,0xC2,0x81,0x12,0xCC,0xAE,0x77,0xE2,0x4C,0x56,0x21,0x58,0xD3,0xC9,0xC0,0xCC,
					0x78,0x58,0x14,0x8D,0x9B,0xA2,0x38,0xFF,0xA0,0x1D,0x65,0xBB,0xB4,0xBA,0xA1,0xCB,
				},
				{	0x66,0xB8,0x96,0x10,
					0xE4,0xA1,0x17,0x08,0x9E,0x22,0xF3,0x8E,
					0x8E,0xCD,0xD2,0x1E,0x9E,0xF3,0x9D,0x69,0x9B,0xA2,0x1D,0x6D,0x24,0x31,0x3A,0xEF,
					0xA8,0xFA,0xB3,0xD5,0x3C,0x04,0x3D,0x81,0xAA,0x0A,0xC4,0xC7,0xBC,0xB7,0x99,0xFA,
					0xFB,0x33,0x93,0x9A,0xCA,0x0B,0x86,0xA1,0x9E,0xE3,0x48,0x61,0xA9,0x3E,0x84,0xEE,
					0xC0,0xCD,0xF0,0x68,0xAA,0x39,0xA2,0xC8,0xE2,0xC9,0x8A,0x38,0xF5,0xC6,0x66,0x4B,
				},
				{	0x3e,0x75,0x00,0x02,
					0x4E,0xC9,0x9C,0xBC,0x3B,0x6D,0x67,0x3A,
					0xC1,0xA8,0x9E,0xDC,0xEC,0x6E,0x70,0xC6,0x1A,0xB9,0x77,0x11,0x6A,0x87,0xE9,0x2C,
					0xF7,0xDD,0x14,0x15,0x1E,0x53,0x7D,0x40,0xC1,0x99,0xBF,0x36,0xAC,0x8C,0x70,0x15,
					0xC3,0xC8,0x5D,0x4B,0x4E,0x6E,0xC3,0xBD,0x70,0xE6,0x21,0x23,0x2C,0xF0,0x81,0xE8,
					0x87,0xEA,0x6F,0x46,0x11,0x53,0x1E,0x32,0x4A,0x2A,0xF2,0x02,0x79,0x89,0x9C,0x21,
				},
				{	0x66,0xB7,0xE8,0xFE,
					0x6C,0x14,0x73,0x24,0x2A,0x7F,0x93,0xA6,
					0x89,0x9E,0x74,0xC3,0x7C,0x8E,0x78,0x31,0xB7,0xAB,0x5A,0x12,0xE5,0x1E,0x0D,0xAE,
					0x95,0x00,0x93,0xAA,0xB3,0x7F,0xD0,0x26,0x65,0xA0,0x90,0x4E,0x4F,0xD6,0xC3,0xA6,
					0xC6,0x7E,0x64,0x0C,0x0D,0x43,0xEA,0x84,0xB0,0x7D,0xAF,0x21,0x02,0x37,0xE5,0xCA,
					0x40,0x8A,0xAC,0x93,0xF2,0xBE,0x4B,0x7D,0x82,0x90,0x98,0x90,0x32,0x8C,0x82,0x2D,
				},
				{	0x66,0xB0,0x51,0xF7,//203432462850//
					0x4D,0xC3,0x52,0xB5,0x33,0xCA,0xA5,0x37,
					0x99,0x4C,0x2E,0x93,0x91,0x95,0x57,0x60,0xCF,0x1D,0x23,0x58,0x1A,0xBC,0x7D,0xEA,
					0x18,0xFE,0x1C,0x5C,0x8C,0x05,0x40,0x3A,0x5F,0xE3,0x81,0x92,0x48,0xCD,0xBB,0xB1,
					0xF2,0xCE,0x95,0xA3,0x5E,0x08,0xE0,0xA9,0x9E,0xB8,0xEC,0x3C,0xBE,0x04,0x19,0xB0,
					0x46,0x55,0x8B,0xF2,0x62,0xD5,0x02,0xC9,0x17,0x5A,0x3D,0x2E,0x5B,0x05,0xDF,0xA3,
				},
				{	0x3E,0x63,0x00,0x8A,
					0x8C,0xC8,0x83,0x76,0x68,0xA0,0xC5,0xC5,
					0xD4,0x9C,0x16,0x2C,0xAC,0xEE,0xDA,0x22,0xB4,0x04,0x7D,0x6C,0x43,0x54,0xA8,0xE5,
					0x97,0xC0,0x51,0x5C,0x9D,0x71,0x14,0xB3,0x64,0x72,0x06,0xE0,0xCE,0x36,0x36,0xAE,
					0x89,0x1E,0x7B,0x04,0xAD,0xA4,0x61,0xC2,0x46,0x72,0xE6,0x51,0x6B,0xC3,0x2B,0x38,
					0x76,0xB3,0xAE,0xF8,0xDF,0xCD,0xFF,0xAB,0x87,0x04,0x3A,0x2F,0xEB,0x16,0xE3,0xD3,
				},
				{	0x66,0xB9,0x41,0x77,
					0x23,0xC3,0xBD,0x44,0xC4,0xDB,0xFD,0xAE,
					0x9C,0xF3,0xDC,0xA2,0x8A,0x54,0xBE,0x76,0xFB,0xA7,0x87,0x8C,0x54,0xAE,0x10,0x02,
					0x5D,0x84,0xBD,0xCA,0xC4,0xE3,0x25,0x0C,0x09,0x1C,0x3B,0x9C,0xB9,0xCF,0x38,0x8C,
					0xAD,0xA8,0x2F,0x6E,0x5F,0x8C,0xE7,0xB1,0x0D,0x65,0xE8,0x01,0xD8,0xF9,0xE8,0xA1,
					0x1E,0xF1,0x31,0xFA,0x5B,0xA9,0x0B,0xB5,0xBC,0x9A,0xDA,0xE7,0x0C,0x5C,0x1B,0x95,
				},
				{	0x66,0xBA,0xBB,0xD6,	//////Á×À½.2011.5.12
					0x42,0x90,0xED,0x19,0x68,0xB7,0xC4,0x3D,
					0xC9,0xBC,0x3B,0x7C,0xBC,0x14,0xFE,0xB5,0xFA,0x47,0xAC,0xD4,0x90,0x28,0xEE,0xB2,
					0xB4,0x5A,0x37,0x7E,0x56,0x18,0x63,0x24,0x6C,0x0D,0x7F,0xDE,0x09,0x15,0x68,0xF8,
					0xC7,0xD9,0x84,0xEA,0xEB,0x44,0x7B,0x97,0x26,0x2F,0x54,0xE8,0x3B,0x22,0xD9,0x2A,
					0xC6,0x35,0x0B,0x4A,0xCD,0xB2,0x22,0x30,0x71,0xFD,0x06,0x1A,0xB2,0x33,0xB7,0x55,
				},
				{	0x66,0xBB,0x9C,0x06,	//2011.5.23
					0xAF,0x8A,0x65,0xE0,0x9A,0xAB,0x1A,0xE4,
					0xA3,0x9B,0x2C,0x06,0xA6,0xDF,0x50,0x24,0xCE,0x95,0xC5,0xA9,0x00,0x38,0xCE,0x3F,
					0x40,0xAC,0x7A,0xBE,0xA2,0xAC,0x7E,0xB4,0x74,0x20,0xF7,0xF0,0xAB,0x73,0xD9,0x4D,
					0x2B,0x28,0xED,0x24,0x2C,0x2A,0xD5,0x7B,0xCA,0xDE,0x64,0xB0,0x94,0x5A,0x4B,0xCD,
					0x3E,0xD1,0xA3,0xB8,0xE2,0x39,0x5E,0xCB,0x8E,0x59,0x24,0xAC,0xF9,0xC5,0xC0,0x3F,
				},
				{	0x66,0xBA,0x43,0xF6,	//2011.5.23
					0xC2,0x4A,0xED,0xE3,0x22,0x09,0x75,0x8A,
					0xAE,0xAD,0xF0,0xCB,0xE3,0xD6,0x49,0x85,0x97,0xAE,0x3D,0x0B,0x32,0xFA,0xF6,0x1F,
					0xD2,0x55,0xD7,0x13,0xFD,0xF1,0x39,0x51,0xD3,0x56,0x23,0x5F,0xB6,0xCD,0x78,0x1F,
					0xAE,0x6B,0x25,0x40,0xF1,0x3F,0xC7,0xD1,0x9A,0x2F,0x8A,0x05,0x2A,0xB9,0xCB,0x0A,
					0x15,0xFE,0xF7,0x89,0x23,0x57,0x0B,0xE6,0xA6,0x90,0xD5,0x78,0x45,0xEA,0x98,0x67,
				},
				{	0x66,0xBC,0xDB,0x99,	//2011.5.28:2031171137  :2011.11.7
					0x2A,0xC3,0x8F,0xF4,0x7F,0x6C,0x22,0x53,
					0xBB,0xBC,0x95,0xB0,0xF3,0xAF,0xF9,0x67,0xDD,0xE2,0x67,0x44,0x2C,0x60,0xA7,0xD4,
					0x11,0x87,0x65,0xE9,0x82,0x8C,0xBC,0x36,0x2E,0x60,0x29,0x8C,0xB9,0x0F,0xF0,0x88,
					0xD8,0xCB,0x7F,0x9E,0x71,0x8B,0xDB,0x59,0x62,0x92,0x6F,0x18,0x9C,0x13,0x8F,0xCC,
					0xBA,0xAB,0xBE,0xBA,0xE5,0x88,0xD7,0x94,0xA6,0x52,0xE1,0x60,0x4B,0x67,0x9C,0xE5,
				},
				{	0x66,0xB6,0xA4,0xE1,
					0x27,0x16,0xC7,0xDF,0x99,0xB1,0xC1,0xF0,
					0x85,0x31,0xCA,0x06,0x86,0xD9,0x6C,0x3E,0xA9,0x5A,0xC7,0x9F,0xFE,0xDA,0xEB,0xF9,
					0xC3,0xBA,0xD1,0xC9,0x2B,0x91,0xE3,0xDC,0x9B,0xE8,0x4C,0x60,0x60,0xB6,0x58,0x29,
					0x66,0x05,0x9B,0xFD,0x51,0xA0,0x3C,0xFB,0x41,0xE4,0xF5,0x81,0xBF,0xC4,0x3B,0xE7,
					0xC5,0x85,0x73,0xE8,0xDE,0x9D,0xA2,0x42,0xFD,0x01,0x4C,0xAB,0xAE,0x66,0x28,0xDB,
				},
				{	0x69,0x33,0x5A,0x55,
					0x65,0xA1,0x95,0x85,0x6F,0x63,0x20,0x3E,
					0xB0,0xCB,0x20,0xCE,0xA9,0x5C,0x13,0xCD,0x0B,0x71,0x9D,0x6D,0xCB,0xEC,0xD7,0xFF,
					0x0E,0xA7,0x5D,0x90,0x72,0x1D,0x73,0xBE,0xC4,0xFE,0x5A,0xEB,0xA1,0xA5,0xF6,0x84,
					0x8B,0x0B,0x13,0xFD,0x1B,0xAC,0x95,0xE1,0xED,0x1B,0x7E,0x2D,0x51,0x5E,0xAA,0x8C,
					0x4F,0xFE,0xD1,0xA5,0xE8,0xF3,0x84,0x9B,0xB7,0x3E,0x4B,0xEC,0x08,0xF8,0x09,0x5F,
				},
				{	0x66,0xB5,0x51,0x50,
					0xFC,0x12,0xAA,0x41,0xD8,0xBA,0x99,0xD8,
					0xC0,0x45,0xE3,0x75,0x3E,0x4E,0xAA,0x18,0x13,0x91,0x2F,0x3D,0x4A,0xE0,0xC2,0x1A,
					0x44,0x85,0x9B,0x14,0x53,0xEE,0xD1,0x3B,0xAD,0xAB,0x20,0x54,0xCF,0x34,0xFB,0xF1,
					0x20,0xB4,0xFF,0xA2,0x23,0xE3,0x4D,0xF8,0x0A,0x4B,0x6C,0x00,0x75,0xC1,0x12,0x51,
					0x0B,0x51,0xD1,0x18,0xFA,0x87,0xCF,0xFC,0x7D,0x8C,0xAC,0x0B,0x00,0x90,0x5B,0x9D,
				},
				{	0x66,0xB3,0xF0,0x1F,
					0x51,0xF8,0x4F,0x2D,0x22,0x73,0xFD,0xAA,
					0x8E,0x3E,0x5A,0x64,0xD3,0x99,0x53,0x42,0x58,0xE7,0x3D,0xDC,0x63,0xAA,0xEF,0x72,
					0x44,0x00,0xF1,0x72,0xED,0xA1,0xA5,0x11,0x71,0x09,0x4F,0xA5,0x2F,0x87,0x20,0xCE,
					0x37,0xDE,0x57,0x5D,0xFC,0xE7,0x83,0x85,0xE0,0x59,0x8F,0x08,0xCF,0x88,0x24,0x57,
					0x3B,0x3F,0x42,0x97,0x6A,0x83,0x0A,0x47,0xF2,0x64,0x32,0xF2,0xD8,0x8B,0x38,0x95,
				},
				{	0x66,0xBD,0xC4,0xBA,
					0xC1,0x9B,0x5A,0x6B,0x28,0x27,0x62,0x1F,
					0xD6,0x5C,0x70,0xE1,0x54,0x98,0x06,0x16,0xB4,0xFE,0xD1,0x4E,0xFC,0x96,0xEF,0x6C,
					0x5F,0xC0,0x96,0xD3,0xC2,0x19,0x1C,0xC0,0xA0,0x42,0xDB,0x02,0x8D,0x28,0x3F,0x78,
					0xE9,0x5B,0x97,0xC1,0x05,0x5C,0xC9,0xDF,0xCF,0x06,0xCA,0xA4,0x3A,0x65,0xF9,0xEC,
					0x99,0xA2,0x84,0x91,0x49,0xE3,0x8E,0x82,0xC7,0x95,0x3E,0xC3,0x93,0x80,0xCD,0x65,
				},
				{	0x69,0x33,0xFA,0x7D,
					0xE0,0x02,0x0C,0x70,0x8E,0x73,0x4F,0xAE,
					0x97,0x53,0xB0,0xA1,0x41,0xC4,0x69,0x68,0x27,0xD4,0xCB,0x2C,0x35,0x69,0x56,0x40,
					0x7F,0xEE,0x5B,0x8D,0x05,0x9B,0x67,0x9F,0xB1,0x3C,0x2F,0xD8,0x0E,0xCB,0x7E,0x12,
					0x0B,0x03,0xEB,0x16,0x31,0x27,0x4B,0x4C,0xFF,0xFB,0x6B,0xC8,0x6D,0xC9,0x19,0xEE,
					0x12,0x06,0x33,0xD4,0xF4,0xBD,0x6A,0x94,0x94,0x75,0x53,0xDF,0x63,0xC2,0x0D,0x2D,
				},
				{	0x69,0x33,0xCC,0x65,
					0xB3,0x49,0xA9,0xA9,0x0B,0x8A,0x5A,0xCA,
					0xC3,0x1C,0x02,0x43,0xF8,0x40,0x9C,0x05,0x5B,0xAB,0xF9,0x21,0x66,0x8B,0x3D,0xBF,
					0xE7,0x59,0x29,0x98,0xA1,0xF0,0x56,0xD0,0x36,0xF7,0x82,0xE1,0x44,0x96,0x5F,0xF0,
					0x1F,0x69,0x6F,0x91,0x0C,0x08,0x19,0xB8,0x74,0x0A,0xA7,0x45,0xC2,0x48,0xA6,0xA7,
					0xFF,0x9B,0x1E,0x79,0x78,0x34,0xC7,0x84,0x4A,0x9C,0xA3,0x4A,0xF6,0x0C,0xEC,0x65,
				},
				{	0x69,0x00,0x43,0xEC,
					0xA0,0x84,0xE0,0xBB,0xED,0xB0,0xDC,0xE5,
					0xC2,0xD8,0x47,0xAD,0xBC,0x1E,0x7E,0x12,0x24,0xB3,0x8D,0xE9,0x23,0x68,0x67,0x22,
					0x58,0xCB,0x3C,0x0F,0x6B,0x06,0x66,0xD9,0x08,0x35,0x3A,0xD8,0xA8,0xE8,0x6B,0x2A,
					0xDB,0x31,0xA5,0x96,0x7F,0x39,0x75,0x15,0xD0,0xF4,0x7E,0xD7,0x1C,0xFF,0x3A,0x2D,
					0xBD,0x11,0x6D,0xC3,0xA6,0xA2,0x7E,0xC6,0x77,0x1E,0x4F,0x5A,0xD1,0x19,0x6D,0x85,
				},
				{	0x69,0x32,0x80,0x9E,               //2031950953
					0x43,0xBB,0x32,0x1B,0xB5,0x03,0x60,0xB4,
					0xC4,0x80,0x51,0xA7,0xC1,0xED,0xA8,0x30,0x03,0x32,0xF6,0x6C,0x30,0x34,0x13,0xF8,
					0xFF,0x32,0x9A,0xBA,0x80,0xF4,0xBB,0x34,0x11,0xF5,0x60,0x58,0xD9,0xBF,0xE7,0x3D,
					0xE2,0xBD,0x2A,0x14,0x07,0x5B,0x32,0x9D,0x9A,0x7E,0x29,0x8B,0xAA,0x70,0x8C,0x19,
					0x0A,0xB9,0xC9,0x6B,0x0E,0x99,0x32,0x90,0x82,0x45,0x40,0xEC,0x63,0x59,0xD6,0xA3,
				},
				{	0x66,0xB4,0x07,0x02,               //2034571476
					0x3C,0xC2,0x94,0x7B,0xA7,0x4E,0x23,0x79,
					0x96,0x81,0xCD,0x90,0xE6,0x70,0xCC,0xD2,0x9A,0xD5,0x9B,0x9B,0x5C,0x0B,0x7E,0xB9,
					0xF7,0xD4,0xB0,0xC9,0x6C,0x89,0x1A,0x4A,0xD8,0x0D,0xFB,0x82,0xE4,0x6F,0x59,0x07,
					0x29,0x3C,0xD3,0xE6,0x55,0x9D,0xCC,0xB2,0x6F,0xEC,0x96,0x1A,0xB6,0x12,0x58,0x34,
					0xA9,0x72,0x94,0x4C,0xB3,0xD5,0x6A,0x16,0x8F,0xB1,0x93,0x07,0x68,0x0F,0xB7,0x4B,
				},

				{	0x63,0xB8,0x0B,0x85,								//2034717681
					0x45,0x1D,0x44,0x5D,0x00,0x75,0x17,0xB6,
					0x98,0xD1,0xE4,0x21,0x48,0x82,0xAD,0x74,0xE4,0x10,0xAF,0x9A,0x74,0x70,0x45,0xB9,
					0xA3,0x04,0x44,0x00,0xAB,0x20,0x21,0xE3,0x1D,0x95,0x3B,0x8D,0xEB,0xFA,0xF9,0x1B,
					0xC2,0xF5,0x81,0x42,0xB5,0xD3,0xB1,0x55,0xD5,0x2D,0x7C,0x7E,0xA3,0x00,0xFD,0x72,
					0x80,0xB9,0xF4,0x21,0x4E,0xDA,0x97,0xB2,0x48,0x78,0x58,0xF0,0x24,0x31,0x3D,0xC9,
				},

				{	0x69,0x39,0x3A,0x11,		//2034686452
					0xC1,0x1C,0x50,0x9A,0x53,0x40,0x5A,0xE9,
					0x82,0xA5,0x62,0x88,0xC0,0xFE,0xB8,0xA9,0xCE,0x61,0x72,0xA8,0x8C,0xF1,0x9E,0x5B,
					0x9C,0xE3,0x8C,0x54,0x22,0x4E,0xE0,0xE3,0x50,0xFE,0x2B,0x8C,0x85,0x0B,0x27,0x07,
					0x56,0x2D,0xA7,0x42,0x22,0xA9,0xF5,0xC5,0x1F,0xFD,0x7F,0x6C,0xB3,0xEA,0x63,0x13,
					0x8F,0x08,0xE6,0x88,0x35,0x70,0x13,0xB6,0x64,0x8E,0x95,0xCA,0x93,0x1C,0x10,0x5D,
				},
				{	0x69,0x39,0x3A,0x4B, //2046202768
					0x6B,0xB0,0x06,0xC9,0xD2,0xB3,0x71,0xC5,
					0x8C,0x78,0x63,0xFA,0xEC,0xE5,0xDC,0x9B,0x22,0xC2,0x6E,0xF8,0x37,0x7A,0xC5,0xAC,
					0xF6,0x9A,0x7B,0x7A,0xE6,0xC8,0xA2,0xA4,0x66,0xA6,0xD3,0xFC,0x10,0x08,0x1C,0x8E,
					0xF0,0x43,0x9E,0xA7,0x9B,0x90,0x10,0x72,0x2C,0x1A,0xB5,0xA4,0x47,0xAA,0xBD,0x86,
					0x87,0x30,0x29,0xDC,0x86,0xA3,0x73,0x83,0x87,0x69,0xCE,0xBE,0x87,0x3A,0x00,0xA3,
				},
				{	0x66,0xB0,0xD6,0xE6,
					0x74,0xC0,0xB6,0x2D,0x3A,0x22,0x9C,0x76,
					0x9E,0x51,0x52,0xCF,0xDF,0xF8,0x22,0x8C,0x47,0x63,0x38,0xBB,0xA8,0x2C,0x2F,0xDF,
					0xC8,0xEF,0x1B,0xC1,0x75,0x33,0xBD,0x78,0x8C,0xE1,0x17,0x84,0xB0,0x8D,0x1A,0x33,
					0x9F,0xA5,0xDF,0x93,0x91,0x82,0x3A,0xB0,0x5F,0xE5,0xE1,0x5B,0xAD,0x21,0x22,0x1D,
					0xCD,0xBA,0x44,0xBA,0x78,0xF0,0x88,0xDF,0x9F,0x22,0xA3,0x8A,0xF0,0x13,0x24,0x51,
				},
				{	0x66,0xB4,0xFD,0x8E,
					0xC3,0xA5,0xA7,0x6F,0x45,0x04,0x37,0xAD,
					0xCF,0x4B,0x86,0x1E,0xA7,0xFA,0x0D,0xB1,0x3C,0x8D,0x42,0x62,0x37,0x0F,0x60,0xED,
					0x62,0x7D,0x79,0x07,0xDF,0xF7,0xFE,0xCD,0xAD,0x67,0xD6,0x74,0x92,0xE3,0x09,0xA7,
					0x7F,0x70,0xDD,0x30,0x54,0xB0,0xE9,0x2A,0x34,0x29,0x07,0xBA,0xFD,0x33,0x57,0xEC,
					0x59,0x31,0x86,0xC0,0xDD,0xA8,0x84,0x06,0xE9,0xBE,0xC0,0x37,0xEC,0x30,0x58,0x9F,
				},
				{	0x66,0xB9,0xEE,0xC3,
					0xBF,0x6D,0x95,0xA0,0xA7,0xF6,0x3F,0xAE,
					0xA7,0xA6,0xB9,0xD0,0x4F,0xBF,0xD6,0x57,0xCF,0x7A,0x12,0x86,0x95,0x91,0x8A,0xB2,
					0xF4,0xFB,0xBF,0xC0,0xBE,0xBB,0x09,0xBC,0xE3,0x09,0x2C,0xA9,0x4B,0x81,0x36,0x64,
					0x9F,0xB3,0x88,0x89,0x44,0x96,0x18,0xD0,0xCD,0xAE,0xA9,0xBD,0x32,0xE3,0x18,0x7B,
					0x92,0x08,0x4E,0x9D,0x5C,0x99,0xF9,0x7C,0x50,0x67,0x9B,0x0B,0x52,0x70,0x90,0xBD,
				},
				{	0x69,0x39,0x0C,0x3B,  //203662626378
					0xBD,0xD4,0x6A,0x78,0x9D,0xE8,0xC4,0x1E,
					0x85,0x08,0xFA,0xC5,0x06,0xA4,0x87,0x6D,0x13,0x90,0xB4,0xF6,0x97,0xE8,0x59,0x5D,
					0x76,0xF4,0xB0,0xBC,0x88,0x98,0x69,0xC0,0xC1,0x7A,0x0D,0x7C,0x31,0xD0,0x9C,0x42,
					0xBB,0xFD,0xA8,0xFF,0x4A,0x1A,0x83,0xBC,0x82,0x51,0x69,0xFF,0xEF,0x23,0xCD,0x1E,
					0x4A,0x55,0x75,0x4B,0x90,0x76,0x3A,0x76,0x44,0x23,0x1E,0x9B,0xD0,0x1D,0xCD,0x17,
				},
				{	0x69,0x39,0x3A,0x34,  //2046332733
					0xDB,0x45,0x12,0x73,0xA1,0x9B,0x00,0x38,
					0xC9,0x25,0x4C,0xC9,0x1F,0x95,0xA7,0xA8,0x9C,0xF8,0x52,0xCF,0xDF,0x30,0x05,0x39,
					0x37,0xDE,0x9F,0xF2,0xA7,0x97,0xF4,0x46,0xC0,0xB0,0xF4,0x3B,0x18,0xE3,0xBC,0x9C,
					0x52,0x53,0x99,0x4C,0xE7,0xEE,0x0F,0x9C,0x0E,0xB3,0x24,0x9E,0x27,0x3B,0xEA,0xB3,
					0xD3,0x00,0x59,0x0D,0x70,0x60,0x48,0x91,0x3A,0xD3,0xC0,0x1B,0x89,0xE1,0x37,0x23,
				},
				{	0x66,0xB6,0x73,0x23, //2034376128
					0xB9,0x37,0x4F,0x2E,0x7D,0x0B,0xC3,0xAA,
					0x81,0x4F,0x5F,0xBF,0x68,0xF6,0x7B,0x87,0x79,0x4B,0x4A,0x3A,0x22,0xA3,0x5F,0x30,
					0x90,0xD2,0x93,0x70,0x44,0xAB,0x9F,0xA3,0xED,0xE0,0x7F,0x3B,0xCE,0x16,0x49,0x74,
					0x68,0x69,0x1D,0xA8,0x0C,0x9C,0x60,0xBC,0x4F,0x57,0xCE,0x98,0x67,0xD2,0x7C,0x2C,
					0x00,0x80,0xAA,0x8A,0xCB,0xB6,0x66,0xDF,0x17,0x30,0x84,0xEE,0x6A,0x6E,0x25,0x99,
				},
				{	0x6B,0x8D,0x00,0xDC, //2036875675
					0x18,0xB5,0x66,0xEE,0x61,0x8B,0xA9,0xC2,
					0x85,0xE4,0xCD,0xDC,0x45,0x2C,0x05,0x2E,0xED,0xB3,0x82,0x82,0x2B,0xAF,0x03,0x93,
					0x61,0xDF,0x2D,0xC8,0x00,0x89,0x7D,0xB3,0xCF,0xFC,0x24,0x72,0x9E,0x5D,0x2A,0x8D,
					0xE4,0xDD,0xF6,0x19,0xF9,0x2B,0x28,0xCB,0xA0,0x84,0x41,0x34,0x7B,0x33,0x22,0xAD,
					0x1F,0x65,0x8E,0x93,0x27,0x6E,0x5F,0xFD,0x23,0x9D,0xA5,0xF5,0x9A,0x97,0x4F,0x43,
				},
				{	0x66,0xB8,0x3B,0xA0,//203707703651
					0x08,0x25,0x77,0xF9,0x2A,0x86,0x63,0x91,
					0x92,0xE9,0x79,0xBE,0xA0,0xC2,0x1A,0xC6,0x78,0xBA,0xB6,0xA6,0x09,0xB4,0x2B,0x82,
					0x56,0x10,0xA0,0x93,0x46,0xA0,0x99,0xB8,0xCC,0x35,0xA9,0xE9,0xC8,0xE3,0x3E,0xA8,
					0xF0,0xDC,0x8D,0x75,0x79,0x98,0x05,0x85,0x8C,0xED,0xA4,0x78,0x41,0xCC,0xC3,0x8D,
					0xB9,0x17,0x7D,0xC2,0xAB,0xB3,0x78,0x08,0x1B,0x96,0x2C,0x46,0x0D,0x4E,0xB7,0x73,
				},
				{	0x6B,0x86,0x5D,0xC5,//203707703954
					0xF3,0x17,0x72,0xFB,0xEA,0xF7,0x56,0x7C,
					0x97,0x02,0xAC,0x76,0x9D,0xF1,0xBB,0x57,0xDF,0x3A,0xE4,0x10,0x45,0x2C,0x8A,0x34,
					0xCD,0xF0,0x79,0x25,0x17,0x68,0xEE,0xE3,0xCD,0xF2,0xEF,0x8E,0xE9,0xB1,0xBD,0x2D,
					0xF6,0x04,0xDB,0x89,0xBC,0x08,0xCD,0x92,0x89,0x10,0x09,0x2B,0x98,0x5A,0xC7,0x47,
					0x39,0x8F,0xF0,0x26,0xF1,0x18,0xC7,0x1A,0x96,0xD4,0x9E,0x97,0x43,0x4C,0xF6,0x49,
				},
				{	0x66,0xBD,0x68,0x81,//203707703550
					0x3E,0x13,0x2F,0x62,0x23,0x6A,0x0F,0xDF,
					0x90,0x72,0xE1,0x57,0x2C,0x3A,0x2A,0x6C,0xA0,0xE3,0x25,0xA6,0x47,0xD6,0x8D,0x39,
					0xFD,0x35,0x67,0x98,0x2C,0x80,0x95,0x83,0x4B,0x04,0x16,0xF1,0x06,0xD2,0x50,0x1E,
					0x54,0xD1,0x62,0x36,0xFF,0x28,0x83,0x56,0x84,0x4A,0xB4,0xCA,0xA7,0x46,0xDD,0xDF,
					0x58,0x91,0xAB,0x4C,0xF7,0x9D,0xB7,0xEF,0xAF,0xB2,0x91,0xFE,0x68,0x3C,0x4B,0x41,
				},
				{	0x69,0x38,0x3E,0xC4,//203643589616
					0x79,0x32,0xCA,0x45,0xAD,0x1C,0x93,0x16,
					0x82,0xCF,0x77,0x1F,0x2A,0x2E,0x29,0x22,0xBD,0xA8,0x9C,0x79,0xE6,0xCF,0xCB,0xF8,
					0xC5,0x2B,0x1F,0x50,0x96,0x87,0xD9,0x35,0xBD,0x27,0x4E,0x07,0xFD,0xAE,0x99,0x2A,
					0x94,0xB8,0xA1,0x1F,0xFD,0x05,0xE3,0x22,0x6D,0x31,0x0E,0x67,0x26,0xCF,0x82,0xA5,
					0x88,0x33,0x35,0x5D,0x04,0x0F,0xCF,0x0E,0x8C,0x79,0x85,0xB0,0xAD,0x77,0x2C,0xA3,
				},
				{	0x69,0x03,0x86,0x4D, //203497733148-->203526702137:CARDONLY
					0x88,0x57,0x27,0x4D,0x4B,0xB0,0xFA,0x66,
					0x88,0xF1,0x71,0x78,0x50,0x26,0x4D,0x59,0x7B,0xB8,0x5A,0x11,0x71,0x6B,0xA5,0x57,
					0x3A,0xEC,0xEE,0xC6,0x35,0x36,0x80,0x6E,0x55,0x5E,0x6D,0xA4,0xF0,0xDE,0xB8,0x93,
					0xC1,0x5D,0xEA,0xD4,0x70,0xE1,0x9B,0x81,0xE3,0xC9,0x92,0x19,0x8C,0x1F,0x07,0x89,
					0x6D,0xD2,0xF4,0x92,0xD9,0x98,0x15,0xA8,0x48,0xBF,0x27,0x7D,0xF5,0x9E,0x62,0x37,
				},
				{	0x69,0x33,0x5D,0xBA,//203114220613==>1
					0x56,0xC2,0xD3,0xF6,0xCE,0x1F,0x37,0x16,
					0xCB,0x98,0x67,0x0F,0xE6,0x3D,0xD2,0xA5,0x57,0xE6,0xAE,0xD3,0x35,0x0A,0x68,0x28,
					0x97,0x39,0xCB,0x7E,0x5C,0xDA,0x01,0x96,0x99,0xDB,0x7E,0x0D,0x24,0xBD,0x70,0xB8,
					0x4C,0x6B,0x4B,0xF3,0x19,0x4F,0x23,0x5E,0xE2,0xA6,0x30,0x38,0x27,0xA4,0x3F,0x5E,
					0x1B,0x1C,0x8E,0xCC,0x40,0xDB,0x53,0xB8,0x28,0xCA,0x1C,0x9B,0x0F,0x76,0x4B,0xDB,
				},
				{	0x66,0xB4,0x53,0x47,//203434125559==>2
					0x29,0xB1,0xFD,0x6B,0xB5,0xAC,0x97,0x2B,
					0x84,0x33,0x03,0xE5,0x28,0xEB,0x86,0xD5,0x19,0xF7,0x9D,0x41,0xBE,0xD9,0x53,0xC1,
					0x38,0x83,0xD3,0x6C,0xF4,0x0D,0xB8,0xCB,0xB8,0x0E,0xF4,0x72,0x2C,0xC7,0xC9,0x5A,
					0x31,0x20,0xD8,0xFC,0xEB,0x10,0x45,0xD7,0x25,0xC7,0xED,0xCF,0xA7,0xFB,0x5D,0x01,
					0xB3,0x74,0xCB,0x8A,0x50,0x2A,0x56,0xCF,0x1D,0x1E,0xD2,0xB8,0x15,0x75,0x85,0xD3,
				},
				{	0x69,0x32,0x03,0x41, //203192623135==>3
					0xC8,0x4C,0x64,0xAE,0x12,0x55,0x5D,0xDD,
					0x91,0x2A,0x20,0x61,0x8F,0x4E,0x41,0xE5,0x0E,0xB4,0x6B,0x86,0xB9,0x19,0x86,0xC9,
					0xC8,0x4C,0xE1,0x01,0x95,0x88,0x7F,0xBD,0xDC,0x58,0xEE,0xC0,0x2E,0x60,0xD0,0x68,
					0x86,0x43,0x48,0xD9,0xDB,0x2C,0x79,0xA6,0x1D,0x56,0x63,0xD3,0x03,0x2C,0x45,0x7C,
					0x96,0xB9,0xA1,0xBC,0x37,0xB7,0x03,0xD4,0xC8,0x50,0xCB,0x41,0xD2,0xBD,0x50,0x1B,
				},
				{	0x6B,0x92,0xD0,0xBA,//203589588284==>4
					0x4F,0x17,0x37,0x76,0xEB,0xC4,0xBB,0x9A,
					0x8C,0x44,0xA2,0xA1,0xFE,0x95,0x0E,0xB1,0x16,0x38,0x20,0x6F,0xB0,0xA0,0x79,0xF4,
					0x49,0x18,0x91,0xBD,0xD4,0xB7,0xB7,0x14,0x88,0x4B,0x65,0x03,0xFF,0x24,0x8F,0x8A,
					0x8C,0x44,0x9D,0x25,0xE0,0x2F,0xBF,0xE1,0xC1,0x4B,0x2C,0x04,0x73,0xA1,0xB0,0x7B,
					0x63,0x79,0x44,0x50,0x6B,0x36,0x95,0xBC,0xCB,0x3D,0xE1,0x5A,0x5C,0xA2,0x38,0x37,
				},
				{	0x66,0xB2,0x10,0x41,//203643579616==>5
					0x17,0xBD,0xA7,0x88,0x27,0x97,0x3B,0x37,
					0x87,0xED,0x4C,0xE3,0x9A,0xC1,0x5E,0xCF,0xB4,0xDD,0xAC,0xB7,0x82,0xE2,0xB5,0x7C,
					0x8B,0xC9,0x8F,0x78,0x2C,0xC6,0x67,0xDE,0x9B,0x6A,0x34,0xE0,0xE2,0x57,0x17,0x15,
					0x98,0x5D,0xBA,0xC4,0x7E,0x43,0x71,0xFB,0x3C,0x20,0xBE,0xA8,0xB1,0xFC,0x14,0xDA,
					0xAD,0xD2,0x88,0xFE,0xE6,0xF7,0xBE,0xCA,0x41,0x6F,0xFA,0xEE,0xAF,0xBA,0x79,0xA1,
				},
				#endif
			#else
				{	0x66,0xA1,0xDC,0xA4,
					0x37,0x93,0x7D,0xE0,0xF0,0x97,0x67,0x37,
					0xB1,0x23,0xA1,0x2F,0x8B,0x84,0xC4,0x2B,0x64,0x97,0x23,0xC9,0x27,0xA0,0xFC,0x40,
					0xDA,0x4A,0xD3,0x85,0x38,0xEC,0xA1,0x5C,0xC1,0xE0,0x38,0xBD,0xB6,0xEF,0x91,0x5F,
					0x22,0x57,0x8B,0xF9,0xED,0x2A,0xAA,0x51,0xA7,0x7B,0xF7,0xDD,0xC1,0x3B,0xD8,0x54,
					0xD1,0x4A,0x4B,0xA6,0xAC,0xE9,0xC1,0xE5,0xE7,0xCC,0x3F,0xC1,0x4C,0xE7,0x21,0x65,
				},
			#endif
	};

	static int ChkDT08OfIrdIds(uint8_t *irdid)
	{
		int i, num;
		num = sizeof(ukcable_dt08_natives) / UKCABLE_DATALENN;
		for(i=0; i<num; i++) {
			if (memcmp(irdid, ukcable_dt08_natives[i], 4) == 0) return i;
		}
		return -1;
	}
#endif // defined(__simulation_ukcable__)
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
// Card Status checks
#define HAS_CW()      ((csystem_data->cam_state[2]&6)==6)
#define RENEW_SESSIONKEY() ((csystem_data->cam_state[0]&128)==128 || (csystem_data->cam_state[0]&64)==64 || (csystem_data->cam_state[0]&32)==32 || (csystem_data->cam_state[2]&8)==8)
#define SENDDATETIME() (csystem_data->cam_state[0]&8)
// Datatypes
#define DT01        	0x01
#define IRDINFO     	0x00
#define TIERS       	0x05
#define DT06        	0x06
#define CAMDATA     	0x08

#define SYSTEM_NAGRA 0x1800
#define SYSTEM_MASK 	0xFF00


static time_t tier_date(uint32_t date, char *buf, int32_t l)
{
	time_t ut=870393600L+date*(24*3600);
	if (buf)
	{
		struct tm t;
    	t.tm_isdst = -1;
		cs_gmtime_r(&ut, &t);
	//	sky(date)
	//	snprintf(buf, l, "%04d/%02d/%02d", t.tm_year+1900, t.tm_mon+1, t.tm_mday);
		snprintf(buf, l, "%02d/%02d/%04d", t.tm_mday, t.tm_mon + 1, t.tm_year + 1900);
	}
	return ut;
}

static char *nagra_datetime(struct s_reader *rdr, uint8_t *ndays, int32_t offset, char *result, time_t *t)
{
	struct nagra_data *csystem_data = rdr->csystem_data;
	struct tm tms;
	memset(&tms, 0, sizeof(tms));
	int32_t days = (ndays[0] << 8 | ndays[1]) + offset;
	int32_t sec = 0;
	if (!csystem_data->is_tiger)
		sec = (ndays[2] << 8 | ndays[3]);
	if (days > 0x41B4 && sizeof(time_t) < 8) // to overcome 32-bit systems limitations
		days = 0x41A2;                   // 01-01-2038
	tms.tm_year = 92;
	tms.tm_mday = days + 1;
	tms.tm_sec  = sec;
	time_t ut = mktime(&tms);
	if (t)
		*t = ut;
	if (csystem_data->is_tiger)
		snprintf(result, 11, "%02d/%02d/%04d", tms.tm_mday, tms.tm_mon + 1, tms.tm_year + 1900);
	else
   //	sky(date)
	//	snprintf(result, 17, "%04d/%02d/%02d %02d:%02d", tms.tm_year + 1900, tms.tm_mon + 1, tms.tm_mday, tms.tm_hour, tms.tm_min);
		snprintf(result, 17, "%02d/%02d/%04d %02d:%02d", tms.tm_mday, tms.tm_mon + 1, tms.tm_year + 1900, tms.tm_hour, tms.tm_min);
	return result;
}

static int32_t do_cmd(struct s_reader *reader, unsigned char cmd, int32_t ilen, unsigned char res, int32_t rlen, const unsigned char *data, unsigned char *cta_res, uint16_t * p_cta_lr)
{
	/*
	here we build the command related to the protocol T1 for ROM142 or T14 for ROM181
	the only different that i know is the command length byte msg[4], this msg[4]+=1 by a ROM181 smartcard (_nighti_)
	one example for the cmd$C0
	T14 protocol:       01 A0 CA 00 00 03 C0 00 06 91
	T1  protocol: 21 00 08 A0 CA 00 00 02 C0 00 06 87
	*/
	int32_t msglen=ilen+6;
	unsigned char msg[msglen];
	static const char nagra_head[] = {0xA0, 0xCA, 0x00, 0x00};
	struct nagra_data *csystem_data = reader->csystem_data;

	memset(msg, 0, msglen);
	memcpy(msg,nagra_head,4);
	msg[4] = ilen;
	msg[5] = cmd;
	int32_t dlen=ilen-2;
	msg[6] = dlen;
	if (data && dlen>0) memcpy(msg+7,data,dlen);
	msg[dlen+7] = rlen;
	if (dlen<0)
	{
		rdr_log_dbg(reader, D_READER, "invalid data length encountered");
		return ERROR;
	}
	if (csystem_data->is_pure_nagra==1)
	{
		msg[4]+=1;
	}
	if (!reader_cmd2icc(reader, msg,msglen, cta_res, p_cta_lr))
  	{
		cs_sleepms(5);
		if (cta_res[0]!=res)
	  	{
	  		rdr_log_dbg(reader, D_READER, "result not expected (%02x != %02x)",cta_res[0],res);
	  		return ERROR;
	  	}
	  	if ((*p_cta_lr-2)!=rlen)
	  	{
	  		rdr_log_dbg(reader, D_READER, "result length expected (%d != %d)",(*p_cta_lr-2),rlen);
	  		return ERROR;
	  	}
  		return *p_cta_lr;
  	}
	return ERROR;
}

static void ReverseMem(unsigned char *vIn, int32_t len)
{
	unsigned char temp;
	int32_t i;
	for (i=0; i < (len/2); i++)
	{
		temp = vIn[i];
		vIn[i] = vIn[len-i-1];
		vIn[len-i-1] = temp;
	}
}

static void Signature(unsigned char *sig, const unsigned char *vkey,const unsigned char *msg, int32_t len)
{
	IDEA_KEY_SCHEDULE ks;
	unsigned char v[8];
	unsigned char b200[16];
	unsigned char b0f0[8];
	memcpy(b200,vkey,sizeof(b200));
	int32_t i;
	int32_t j;
	for (i=0; i<len; i+=8)
	{
		idea_set_encrypt_key(b200,&ks);
		memset(v,0,sizeof(v));
		idea_cbc_encrypt(msg+i,b0f0,8,&ks,v,IDEA_DECRYPT);
		for (j=7; j>=0; j--) b0f0[j]^=msg[i+j];
		memcpy(b200+0,b0f0,8);
		memcpy(b200+8,b0f0,8);
	}
	memcpy(sig,b0f0,8);
	return;
}

static int32_t CamStateRequest(struct s_reader *reader)
{
	def_resp;
	struct nagra_data *csystem_data = reader->csystem_data;
	char tmp_dbg[10];
	if (do_cmd(reader, 0xC0,0x02,0xB0,0x06,NULL,cta_res,&cta_lr))
	{
		memcpy(csystem_data->cam_state,cta_res+3,3);
		rdr_log_dbg(reader, D_READER, "Camstate: %s", cs_hexdump(1, csystem_data->cam_state, 3, tmp_dbg, sizeof(tmp_dbg)));
	}
	else
	{
		rdr_log_dbg(reader, D_READER, "CamStateRequest failed");
		return ERROR;
	}
	return OK;
}

static void DateTimeCMD(struct s_reader *reader)
{
	def_resp;
	if (!do_cmd(reader, 0xC8,0x02,0xB8,0x06,NULL,cta_res,&cta_lr))
	{
		rdr_log_dbg(reader, D_READER, "DateTimeCMD failed!");
	}
#if __ADB_TRACE__
	char dd[20];
	tier_date(b2i(2, cta_res+2)-0x7f7, dd, 15);
	myprintf("datetime:%s\n", dd);
#endif
}

static int32_t NegotiateSessionKey_Tiger(struct s_reader *reader)
{
	def_resp;
	unsigned char exponent = 0x11;
	unsigned char parte_fija[120];
	unsigned char parte_variable[88];
	unsigned char d1_rsa_modulo[88];
	unsigned char d2_data[88];
	unsigned char sign1[8];
	unsigned char sk[16];
	unsigned char tmp[104];
	unsigned char idea_key[16];
	unsigned char rnd[88];
	char tmp2[17];
	struct nagra_data *csystem_data = reader->csystem_data;

	if (!do_cmd(reader, 0xd1,0x02,0x51,0xd2,NULL,cta_res,&cta_lr))
	{
		rdr_log_dbg(reader, D_READER, "CMD$D1 failed");
		return ERROR;
	}

	BN_CTX *ctx = BN_CTX_new();
#ifdef WITH_LIBCRYPTO_sky
	BN_CTX_start(ctx);
#endif
	BIGNUM *bnN  = BN_CTX_get(ctx);
	BIGNUM *bnE  = BN_CTX_get(ctx);
	BIGNUM *bnCT = BN_CTX_get(ctx);
	BIGNUM *bnPT = BN_CTX_get(ctx);
	// sky()
	unsigned char *pRsaMod = (cs_Iszero(reader->rsa_mod,120)) ? rsaMod_Tigers : reader->rsa_mod;
	BN_bin2bn(pRsaMod, 120, bnN);
	BN_bin2bn(&exponent, 1, bnE);
	BN_bin2bn(&cta_res[90], 120, bnCT);
	BN_mod_exp(bnPT,  bnCT, bnE, bnN, ctx);
	memset(parte_fija, 0, 120);
	BN_bn2bin(bnPT, parte_fija + (120-BN_num_bytes(bnPT)));
	BN_CTX_end(ctx);
	BN_CTX_free (ctx);

	rdr_log_dbg(reader, D_READER, "---------- SIG CHECK ---------------------");
	memset(tmp,0, 104);
	memcpy(tmp+4, parte_fija+11, 100);
	memset(idea_key, 0x37, 16);
	Signature(sign1, idea_key, tmp, 104);
	rdr_log_dbg(reader, D_READER, "sign1: %s", cs_hexdump(0, sign1, 8, tmp2, sizeof(tmp2)));
	rdr_log_dbg(reader, D_READER, "sign2: %s", cs_hexdump(0, parte_fija+111, 8, tmp2, sizeof(tmp2)));
	if (!memcmp (parte_fija+111, sign1, 8)==0)
	{
		rdr_log_dbg(reader, D_READER, "signature check nok");
		rdr_log_dbg(reader, D_READER, "------------------------------------------");
		return ERROR;
	}
	rdr_log_dbg(reader, D_READER, "signature check ok");
	rdr_log_dbg(reader, D_READER, "------------------------------------------");

	memcpy(reader->hexserial+2, parte_fija+15, 4);
	memcpy(reader->sa[0], parte_fija+15, 2);

	memcpy(reader->irdId, parte_fija+19, 4);
	memcpy(d1_rsa_modulo, parte_fija+23,88);

	ReverseMem(cta_res+2, 88);
	BN_CTX *ctx1 = BN_CTX_new();
#ifdef WITH_LIBCRYPTO_sky
	BN_CTX_start(ctx1);
#endif
	BIGNUM *bnN1  = BN_CTX_get(ctx1);
	BIGNUM *bnE1  = BN_CTX_get(ctx1);
	BIGNUM *bnCT1 = BN_CTX_get(ctx1);
	BIGNUM *bnPT1 = BN_CTX_get(ctx1);
	BN_bin2bn(d1_rsa_modulo, 88, bnN1);
	BN_bin2bn(&exponent, 1, bnE1);
	BN_bin2bn(cta_res+2, 88, bnCT1);
	BN_mod_exp(bnPT1, bnCT1, bnE1, bnN1, ctx1);
	memset(parte_variable, 0, 88);
	BN_bn2bin(bnPT1, parte_variable + (88-BN_num_bytes(bnPT1)));
	BN_CTX_end(ctx1);
	BN_CTX_free(ctx1);

	csystem_data->ActivationDate[0] = parte_variable[65];
	csystem_data->ActivationDate[1] = parte_variable[66];
	csystem_data->ExpiryDate[0] = parte_variable[69];
	csystem_data->ExpiryDate[1] = parte_variable[70];

	reader->prid[0][0]=0x00;
	reader->prid[0][1]=0x00;
	reader->prid[0][2]=parte_variable[73];
	reader->prid[0][3]=parte_variable[74];
	reader->caid =(SYSTEM_NAGRA|parte_variable[76]);
	memcpy(sk,&parte_variable[79],8);
	memset(sk + 8, 0xBB, 8);
	rdr_log_sensitive(reader, "type: NAGRA, caid: %04X, IRD ID: {%s}",reader->caid, cs_hexdump(1,reader->irdId,4, tmp2, sizeof(tmp2)));
  	rdr_log(reader, "ProviderID: %s", cs_hexdump(1,reader->prid[0],4, tmp2, sizeof(tmp2)));

	memcpy(rnd, sk, 8);
	memset(&rnd[8], 0xBB, 79);
	rnd[87] = 0x6B;
	ReverseMem(rnd, 88);


	BN_CTX *ctx3 = BN_CTX_new();
#ifdef WITH_LIBCRYPTO_sky
	BN_CTX_start(ctx3);
#endif
	BIGNUM *bnN3  = BN_CTX_get(ctx3);
	BIGNUM *bnE3  = BN_CTX_get(ctx3);
	BIGNUM *bnCT3 = BN_CTX_get(ctx3);
	BIGNUM *bnPT3 = BN_CTX_get(ctx3);
	BN_bin2bn(d1_rsa_modulo, 88, bnN3);
	BN_bin2bn(&exponent, 1, bnE3);
	BN_bin2bn(rnd, 88, bnCT3);
	BN_mod_exp(bnPT3,  bnCT3, bnE3, bnN3, ctx3);
	memset(d2_data, 0, 88);
	BN_bn2bin(bnPT3, d2_data + (88-BN_num_bytes(bnPT3)));
	BN_CTX_end(ctx3);
	BN_CTX_free(ctx3);
	ReverseMem(d2_data, 88);

	if (!do_cmd(reader, 0xd2,0x5a,0x52,0x03, d2_data,cta_res,&cta_lr))
	{
		rdr_log_dbg(reader, D_READER, "CMD$D2 failed");
		return ERROR;
	}
	if (cta_res[2] == 0x00)
	{
		memcpy(csystem_data->sessi,sk,16);
		IDEA_KEY_SCHEDULE ks;
		idea_set_encrypt_key(csystem_data->sessi,&ks);
		idea_set_decrypt_key(&ks,&csystem_data->ksSession);
		rdr_log_dbg(reader, D_READER, "Tiger session key negotiated");
		reader->nagra_negotiate = 1;
		return OK;
	}
	rdr_log(reader, "Negotiate sessionkey was not successful! Please check tivusat rsa key");
//	return ERROR;
	return OK; /* sky */
}

static int32_t NegotiateSessionKey(struct s_reader *reader)
{
	def_resp;
	unsigned char negot[64];
	unsigned char cmd2b[] = {0x21, 0x40, 0x4D, 0xA0, 0xCA, 0x00, 0x00, 0x47, 0x27, 0x45, // 0
                            0x1C, 0x54, 0xd1, 0x26, 0xe7, 0xe2, 0x40, 0x20, // 10
                            0xd1, 0x66, 0xf4, 0x18, 0x97, 0x9d, 0x5f, 0x16, // 18
                            0x8f, 0x7f, 0x7a, 0x55, 0x15, 0x82, 0x31, 0x14, // 26
                            0x06, 0x57, 0x1a, 0x3f, 0xf0, 0x75, 0x62, 0x41, // 34
                            0xc2, 0x84, 0xda, 0x4c, 0x2e, 0x84, 0xe9, 0x29, // 42
                            0x13, 0x81, 0xee, 0xd6, 0xa9, 0xf5, 0xe9, 0xdb, // 50
                            0xaf, 0x22, 0x51, 0x3d, 0x44, 0xb3, 0x20, 0x83, // 58
                            0xde, 0xcb, 0x5f, 0x35, 0x2b, 0xb0, 0xce, 0x70, // 66
                            0x01, 0x02, 0x03, 0x04, //IRD nr                // 74
							       0x00
							      };//keynr
	unsigned char tmp[64];
	unsigned char idea1[16];
	unsigned char idea2[16];
	unsigned char sign1[8];
	unsigned char sign2[8];
	struct nagra_data *csystem_data = reader->csystem_data;

	if (csystem_data->is_tiger)
	{
		if (!NegotiateSessionKey_Tiger(reader))
		{
			rdr_log_dbg(reader, D_READER, "NegotiateSessionKey_Tiger failed");
			return ERROR;
		}
		return OK;
	}

	if (!csystem_data->has_dt08) // if we have no valid dt08 calc then we use rsa from config and hexserial for calc of sessionkey
	{
		rdr_log_dbg(reader, D_READER, "No valid DT08 calc using rsa from config and serial from card");
		memcpy(csystem_data->plainDT08RSA, reader->rsa_mod, 64);
		memcpy(csystem_data->signature, reader->boxkey, 8);
		#if defined(__simulation_ukcable__)
			if (cs_Iszero(reader->rsa_mod,64) && cs_Iszero(reader->boxkey,8))
			{
				int idx;
				if ((idx = ChkDT08OfIrdIds(reader->irdId))>=0) {
					memcpy(csystem_data->plainDT08RSA, &ukcable_dt08_natives[idx][4+8], 64);
					memcpy(csystem_data->signature, &ukcable_dt08_natives[idx][4], 8);
					memcpy(reader->boxkey, &ukcable_dt08_natives[idx][4], 8);
				}
				rdr_log_dbg(reader, D_READER, "ChkDT08OfIrdIds{%02X.%02X.%02X.%02X}", reader->irdId[0], reader->irdId[1], reader->irdId[2], reader->irdId[3]);
			}
		//	myprdump("plainDT08RSA", csystem_data->plainDT08RSA, 64);
		//	myprdump("signature", csystem_data->signature, 8);
		#endif // defined(__simulation_ukcable__)
	}

	if ((csystem_data->is_n3_na) && (!do_cmd(reader, 0x29,0x02,0xA9,0x04, NULL,cta_res,&cta_lr))) {
		rdr_log_dbg(reader, D_READER, "Nagra3: CMD$29 failed");
		return ERROR;
	}

	memcpy(tmp, reader->irdId, 4);
	tmp[4]=0; //keynr 0

	if (!csystem_data->is_n3_na) {
		if (!do_cmd(reader, 0x2a,0x02,0xaa,0x42,NULL,cta_res,&cta_lr)) {
			rdr_log_dbg(reader, D_READER, "CMD$2A failed");
			return ERROR;
		}
	}
	else if (!do_cmd(reader, 0x26,0x07,0xa6, 0x42, tmp,cta_res,&cta_lr)) {
		rdr_log_dbg(reader, D_READER, "CMD$26 failed");
		return ERROR;
	}

	// RSA decrypt of cmd$2a data, result is stored in "negot"
	ReverseMem(cta_res+2, 64);
	unsigned char vFixed[] = {0,1,2,3};
	BN_CTX *ctx = BN_CTX_new();
#ifdef WITH_LIBCRYPTO_sky
	BN_CTX_start(ctx);
#endif
	BIGNUM *bnN  = BN_CTX_get(ctx);
	BIGNUM *bnE  = BN_CTX_get(ctx);
	BIGNUM *bnCT = BN_CTX_get(ctx);
	BIGNUM *bnPT = BN_CTX_get(ctx);
	BN_bin2bn(csystem_data->plainDT08RSA, 64, bnN);
	BN_bin2bn(vFixed+3, 1, bnE);
	BN_bin2bn(cta_res+2, 64, bnCT);
	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
	memset(negot, 0, 64);
	BN_bn2bin(bnPT, negot + (64-BN_num_bytes(bnPT)));

	memcpy(tmp, negot, 64);
	ReverseMem(tmp, 64);

	// build sessionkey
	// first halve is IDEA Hashed in chuncs of 8 bytes using the Signature1 from dt08 calc, CamID-Inv.CamID(16 bytes key) the results are the First 8 bytes of the Session key
	memcpy(idea1, csystem_data->signature, 8);
	memcpy(idea1+8, reader->hexserial+2, 4);
	idea1[12] = ~reader->hexserial[2];
	idea1[13] = ~reader->hexserial[3];
	idea1[14] = ~reader->hexserial[4];
	idea1[15] = ~reader->hexserial[5];

	Signature(sign1, idea1, tmp, 32);
	memcpy(idea2,sign1,8);
	memcpy(idea2+8,sign1,8);
	Signature(sign2, idea2, tmp, 32);
	memcpy(csystem_data->sessi,sign1,8);
	memcpy(csystem_data->sessi+8,sign2,8);

	// prepare cmd$2b data
	BN_bin2bn(negot, 64, bnCT);
	BN_mod_exp(bnPT, bnCT, bnE, bnN, ctx);
	memset(cmd2b+10, 0, 64);
	BN_bn2bin(bnPT, cmd2b+10 + (64-BN_num_bytes(bnPT)));
	BN_CTX_end(ctx);
	BN_CTX_free(ctx);
	ReverseMem(cmd2b+10, 64);

	IDEA_KEY_SCHEDULE ks;
	idea_set_encrypt_key(csystem_data->sessi,&ks);
	idea_set_decrypt_key(&ks,&csystem_data->ksSession);

	memcpy(cmd2b+74, reader->irdId, 4);
	cmd2b[78] = 0; //keynr

	if (!csystem_data->is_n3_na) {
		if (!do_cmd(reader, 0x2b,0x42,0xab,0x02, cmd2b+10,cta_res,&cta_lr)) {
			rdr_log_dbg(reader, D_READER, "CMD$2B failed");
			return ERROR;
		}
	}
	else {
		if (!do_cmd(reader, 0x27,0x47,0xa7,0x02,cmd2b+10,cta_res,&cta_lr)) {
			rdr_log_dbg(reader, D_READER, "CMD$27 failed");
			return ERROR;
		}
	}

	rdr_log_dbg(reader, D_READER, "session key negotiated");

	DateTimeCMD(reader);

	if (!CamStateRequest(reader))
	{
		rdr_log_dbg(reader, D_READER, "CamStateRequest failed");
		return ERROR;
	}
	if RENEW_SESSIONKEY()
	{
		rdr_log(reader, "Negotiate sessionkey was not successful! Please check rsa key and boxkey");
		myprintf("nagra:Please check rsa key and boxkey\n");
	//	return ERROR; /* sky(!) */
	}
	else {
		reader->nagra_negotiate = 1;
	}
	return OK;
}

static void decryptDT08(struct s_reader *reader, unsigned char *cta_res)
{
	unsigned char vFixed[] = {0,1,2,3};
	unsigned char v[72];
	unsigned char buf[72];
	unsigned char sign2[8];
	unsigned char static_dt08[73];
	unsigned char camid[4];
	char tmp_dbg[13];
	int32_t i, n;
	BN_CTX *ctx;
	BIGNUM *bn_mod, *bn_exp, *bn_data, *bn_res;
	struct nagra_data *csystem_data = reader->csystem_data;

	memcpy(static_dt08, &cta_res[12], 73);
	// decrypt RSA Part of dt08
	bn_mod  = BN_new ();
  	bn_exp  = BN_new ();
  	bn_data = BN_new ();
  	bn_res  = BN_new ();
  	ctx	  = BN_CTX_new();
	if (ctx == NULL) {
	  rdr_log_dbg(reader, D_READER, "RSA Error in dt08 decrypt");
	}
  	ReverseMem(static_dt08+1, 64);
  	BN_bin2bn (reader->rsa_mod, 64, bn_mod); // rsa modulus
  	BN_bin2bn (vFixed+3, 1, bn_exp); // exponent
  	BN_bin2bn (static_dt08+1, 64, bn_data);
  	BN_mod_exp (bn_res, bn_data, bn_exp, bn_mod, ctx);
  	memset (static_dt08+1, 0, 64);
  	n = BN_bn2bin (bn_res, static_dt08+1);
  	BN_CTX_free (ctx);
  	ReverseMem(static_dt08+1, n);

  	// RSA data can never be bigger than the modulo
  	static_dt08[64] |= static_dt08[0] & 0x80;

  	// IdeaCamKey
  	memcpy (&csystem_data->IdeaCamKey[0], reader->boxkey, 8);
  	memcpy (&csystem_data->IdeaCamKey[8], reader->irdId, 4);
  	for (i = 0; i < 4; i++)
		csystem_data->IdeaCamKey[12 + i] = ~reader->irdId[i];

  	// now IDEA decrypt
  	IDEA_KEY_SCHEDULE ks;
  	idea_set_encrypt_key(csystem_data->IdeaCamKey,&ks);
  	idea_set_decrypt_key(&ks,&csystem_data->ksSession);
  	memcpy(&buf[ 0], static_dt08+1, 64);
  	memcpy(&buf[64], static_dt08+65, 8);
  	memset(v,0,sizeof(v));
  	memset(static_dt08,0,sizeof(static_dt08));
  	idea_cbc_encrypt(buf,static_dt08,72,&csystem_data->ksSession,v,IDEA_DECRYPT);

  	if (csystem_data->swapCW==1)
  	{
  		memset(camid,0xff,4);
  	}
  	else
  	{
  		memcpy(camid, reader->hexserial+2,4);
  	}
  	rdr_log_dbg(reader, D_READER, "using camid %s for dt08 calc", cs_hexdump(1, camid, 4, tmp_dbg, sizeof(tmp_dbg)));

	// Calculate csystem_data->signature
  	memcpy(csystem_data->signature, static_dt08, 8);
  	memset(static_dt08 + 0, 0, 4);
  	memcpy(static_dt08 + 4, camid, 4);
  	Signature(sign2,csystem_data->IdeaCamKey,static_dt08,72);

	if (memcmp(csystem_data->signature, sign2, 8)==0)
	{
		csystem_data->has_dt08=1;
		memcpy(csystem_data->plainDT08RSA, static_dt08+8, 64);
		rdr_log_dbg(reader, D_READER, "DT08 signature check ok");
	}
	else
	{
		csystem_data->has_dt08=0;
		rdr_log_dbg(reader, D_READER, "DT08 signature check nok");
	}

	BN_free(bn_mod);
	BN_free(bn_exp);
	BN_free(bn_data);
	BN_free(bn_res);
}

static void addProvider(struct s_reader *reader, unsigned char *cta_res)
{
	int32_t i;
	int32_t toadd=1;
	for (i=0; i<reader->nprov; i++)
	{
		if ((cta_res[7]==reader->prid[i][2]) && (cta_res[8]==reader->prid[i][3]))
		{
			toadd = 0;
		}
	}
	if (toadd)
	{
		reader->prid[reader->nprov][0]=0;
  		reader->prid[reader->nprov][1]=0;
  		reader->prid[reader->nprov][2]=cta_res[7];
  		reader->prid[reader->nprov][3]=cta_res[8];
  		memcpy(reader->sa[reader->nprov], reader->sa[0], 4);
 		reader->nprov += 1;
	}
}

static int32_t ParseDataType(struct s_reader *reader, unsigned char dt, unsigned char *cta_res, uint16_t cta_lr)
{
	struct nagra_data *csystem_data = reader->csystem_data;
	char ds[20], de[16];
	uint16_t chid;
	switch (dt)
	{
		case IRDINFO:
		{
			reader->prid[0][0]=0;
  			reader->prid[0][1]=0;
  			reader->prid[0][2]=cta_res[7];
  			reader->prid[0][3]=cta_res[8];
  			if (((cta_res[7] == 0x34) && (cta_res[8] == 0x11)) || ((cta_res[7] == 0x04) && (cta_res[8] == 0x01))) //provider 3411, 0401 needs cw swap
  			{
  				rdr_log_dbg(reader, D_READER, "detect provider with swap cw!");
  				csystem_data->swapCW=1;
  			}

			reader->prid[1][0]=0x00;
			reader->prid[1][1]=0x00;
			reader->prid[1][2]=0x00;
			reader->prid[1][3]=0x00;
			memcpy(reader->sa[1], reader->sa[0], 4);
 			reader->nprov += 1;

			reader->caid =(SYSTEM_NAGRA|cta_res[11]);
			memcpy(reader->irdId,cta_res+14,4);
		   if (reader->csystem_active)          // do not output on init but only afterwards in card_info
		   {
				rdr_log_sensitive(reader, "IRD ID: {%s}", cs_hexdump(1, reader->irdId, 4, ds, sizeof(ds)));
				myprintf("nagra:IRD ID: {%s}\n", cs_hexdump(1, reader->irdId, 4, ds, sizeof(ds)));
				nagra_datetime(reader, cta_res+24, 0, ds, &reader->card_valid_to);
				rdr_log(reader, "active to: %s", ds);
			}
			return OK;
 		}
		case TIERS:
			if ((cta_lr>33) && (chid=b2i(2, cta_res+11)))
  			{
  				int32_t id=(cta_res[7]*256)|cta_res[8];
				int32_t offset = ((reader->caid == 0x1830 || reader->caid == 0x1843)
											&& chid == 0x0BEA) ? -21 : 0;

  				// todo: add entitlements to list
				// sky(!)
				cs_add_entitlement(reader,
							reader->caid,
							id,
							chid,
							0,
							tier_date(b2i(2, cta_res+20)-0x7f7, ds, 15),
							tier_date(b2i(2, cta_res + 13) - 0x7f7 + offset, de, 15),
							4,
							NULL,
							1);


			// tier_date(b2i(2, cta_res+20)-0x7f7, ds, 15);
			// tier_date(b2i(2, cta_res+13)-0x7f7, de, 15);
    			rdr_log(reader, "|%04X|%04X    |%s  |%s  |", id,chid, ds, de);
    			addProvider(reader, cta_res);
    		}
   	case 0x08:
 		case 0x88:
			if (cta_res[11] == 0x49) {
				myprintf("nagra:decryptDT08\n");
				decryptDT08(reader, cta_res);
    		}
   		break;
		default:
			return OK;
	}
	return ERROR;
}

#define MAX_REC	20
static int32_t GetDataType(struct s_reader *reader, unsigned char dt, int32_t len)
{
	def_resp;
	int32_t result = OK;
	int shots = 0;

	while(result == OK && ++shots < MAX_REC)
	{
		if (!do_cmd(reader, 0x22, 0x03, 0xA2, len, &dt, cta_res, &cta_lr))
		{
  			rdr_log_dbg(reader, D_READER, "failed to get datatype %02X",dt);
			result = ERROR;
			break;
		}

		if ((cta_res[2] == 0) && ((dt&0x80) == 0x80))
		{
			result = OK;
			break;
		}
		myprintf("nagra:dtparser.%02x\n", dt);
		if (!ParseDataType(reader, dt & 0x0F, cta_res, cta_lr))
		{
			result = ERROR;
			break;
		}

		if ((cta_res[11] == 0x49) && ((dt&0x80) == 0x80))
		{
			result = OK;
			break;
  		}
		dt |= 0x80; // get next item
	}
	return result;
}

static int32_t nagra2_card_init(struct s_reader *reader, ATR *newatr)
{
	get_atr;
	def_resp;
	memset(reader->rom, 0, 15);
	static const uchar ins80[] = { 0x80, 0xCA, 0x00, 0x00, 0x11 }; // switch to nagra layer
	static const uchar handshake[] = { 0xEE, 0x51, 0xDC, 0xB8, 0x4A, 0x1C, 0x15, 0x05, 0xB5, 0xA6, 0x9B, 0x91, 0xBA, 0x33, 0x19, 0xC4, 0x10 }; // nagra handshake
	int8_t ins7e11_state = 0;

	int8_t is_pure_nagra = 0;
	int8_t is_tiger = 0;
	int8_t is_n3_na = 0;
 	memset(reader->irdId, 0xff, 4);
	memset(reader->hexserial, 0, 8);
	reader->nagra_negotiate = 0;

	cs_clear_entitlement(reader); // reset the entitlements

	if (memcmp(atr + 11, "DNASP240", 8) == 0 || memcmp(atr + 11, "DNASP241", 8) == 0)
	{
		rdr_log(reader, "detect nagra 3 NA card");
		memcpy(reader->rom,atr+11,15);
		is_n3_na = 1;
	}
	else if (memcmp(atr+11, "DNASP", 5)==0)
	{
		rdr_log(reader, "detect native nagra card");
		memcpy(reader->rom,atr+11,15);
	}
	else if (memcmp(atr+11, "TIGER", 5)==0 || (memcmp(atr+11, "NCMED", 5)==0))
	{
		rdr_log(reader, "detect nagra tiger card");
		memcpy(reader->rom,atr+11,15);
		is_tiger = 1;
	}
	else if ((!memcmp(atr+4, "IRDETO", 6)) && ((atr[14]==0x03) && (atr[15]==0x84) && (atr[16]==0x55)))
	{
		rdr_log(reader, "detect irdeto tunneled nagra card");
		if (check_filled(reader->rsa_mod, 64) == 0)
		{
			rdr_log(reader, "no rsa key configured -> using irdeto mode");
			return ERROR;
		}
		if (reader->force_irdeto)
		{
			rdr_log(reader, "rsa key configured but irdeto mode forced -> using irdeto mode");
			return ERROR;
		}
		rdr_log(reader, "rsa key configured -> using nagra mode");
		is_pure_nagra = 1;
		if (!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data))) return ERROR;
		struct nagra_data *csystem_data = reader->csystem_data;
		csystem_data->is_pure_nagra = is_pure_nagra;
		if (!do_cmd(reader, 0x10,0x02,0x90,0x11,0,cta_res,&cta_lr))
		{
			rdr_log_dbg(reader, D_READER, "get rom version failed");
			return ERROR;
		}
		memcpy(reader->rom,cta_res+2,15);
	}
	else if (memcmp(atr + 7, "pp", 2) == 0 && ((atr[9]&0x0F) >= 10))
	{
		rdr_log(reader, "detect seca/nagra tunneled card");

		if (!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data)))
			{ rdr_log(reader,"mem alloc error"); return ERROR; }
		write_cmd(ins80, handshake); // try to init nagra layer
		if (cta_res[0] == 0x61 && cta_res[1] == 0x10)
		{
			reader->seca_nagra_card = 1;
			if ((reader->typ == R_SMART || reader->typ == R_INTERNAL || is_smargo_reader(reader)) && !reader->ins7e11_fast_reset)
			{
				ins7e11_state = 1;
				reader->ins7e11_fast_reset = 1;
			}
			reader->card_atr_length = 23;
			const struct s_cardreader *crdr_ops = reader->crdr;
			if (!crdr_ops) return ERROR;
			call(crdr_ops->activate(reader, newatr)); //read nagra atr
			get_atr2;
			memcpy(reader->rom, atr2 + 8, 15);// get historical bytes containing romrev from nagra atr
			rdr_log(reader,"Nagra layer found");
			rdr_log(reader,"Rom revision: %.15s", reader->rom);
			reader->card_atr_length = 14;
			reader->seca_nagra_card = 2;
			call(crdr_ops->activate(reader, newatr));// read seca atr to switch back
			if ((reader->typ == R_SMART || reader->typ == R_INTERNAL || is_smargo_reader(reader)) && ins7e11_state == 1)
			{
				ins7e11_state = 0;
				reader->ins7e11_fast_reset = 0;
			}
		}
		else
		{
			rdr_log(reader," Nagra atr not ok");
			return ERROR;
		}
		NULLFREE(reader->csystem_data);
		return ERROR; // quitting csystem still not having needed commands to run on nagra layer
	}
	else { return ERROR; }

	// Private data may be already allocated, see above (the irdeto check).
	if (!reader->csystem_data) {
		if (!cs_malloc(&reader->csystem_data, sizeof(struct nagra_data))) return ERROR;
	}
	struct nagra_data *csystem_data = reader->csystem_data;
	csystem_data->is_pure_nagra = is_pure_nagra;
	csystem_data->is_tiger      = is_tiger;
	csystem_data->is_n3_na      = is_n3_na;

	reader->nprov = 1;

	if (!csystem_data->is_tiger)
	{
		CamStateRequest(reader);
		if (!do_cmd(reader, 0x12,0x02,0x92,0x06,0,cta_res,&cta_lr))
		{
			rdr_log_dbg(reader, D_READER, "get serial failed");
			return ERROR;
		}
		memcpy(reader->hexserial+2, cta_res+2, 4);
		memcpy(reader->sa[0], cta_res+2, 2);

		if (!GetDataType(reader, DT01,0x0E)) return ERROR;
		rdr_log_dbg(reader, D_READER, "DT01 DONE");
		CamStateRequest(reader);
		if (!GetDataType(reader, IRDINFO,0x39)) return ERROR;
		rdr_log_dbg(reader, D_READER, "IRDINFO DONE");
		CamStateRequest(reader);
		if (!GetDataType(reader, CAMDATA,0x55)) return ERROR;
		rdr_log_dbg(reader, D_READER, "CAMDATA Done");
		if (!GetDataType(reader, 0x04,0x44)) return ERROR;
		rdr_log_dbg(reader, D_READER, "DT04 DONE");
		CamStateRequest(reader);
		if (!GetDataType(reader, DT06,0x16)) return ERROR;
		rdr_log_dbg(reader, D_READER, "DT06 DONE");
		CamStateRequest(reader);
	}
	if (!NegotiateSessionKey(reader))
	{
		rdr_log_dbg(reader, D_READER, "NegotiateSessionKey failed");
		return ERROR;
	}
	rdr_log(reader, "ready for requests");
	return OK;
}

typedef struct
{
   char date1[11];
   char date2[11];
   uint8_t  type;
   uint16_t value;
   uint16_t price;
} ncmed_rec;

static time_t tiger_date2time(const char *date)
{
   struct tm timeinfo;
   int32_t y, m, d;

   sscanf(date, "%02d/%02d/%04d", &d, &m, &y);
   memset(&timeinfo, 0, sizeof(struct tm));
   timeinfo.tm_year = y - 1900;
   timeinfo.tm_mon  = m - 1;
   timeinfo.tm_mday = d;

   return mktime(&timeinfo);
}

static int32_t reccmp(const void *r1, const void *r2)
{
   int32_t v1, v2, y, m, d;
   sscanf(((ncmed_rec *)r1)->date1, "%02d/%02d/%04d", &d, &m, &y);
   v1 = y * 372 + 1 + m * 31 + d;
   sscanf(((ncmed_rec *)r2)->date1, "%02d/%02d/%04d", &d, &m, &y);
   v2 = y * 372 + 1 + m * 31 + d;
   return (v1 == v2) ? 0 : (v1 < v2) ? -1 : 1;
}

static int32_t reccmp2(const void *r1, const void *r2)
{
   char rec1[13], rec2[13];
   snprintf(rec1, sizeof(rec1), "%04X", ((ncmed_rec *)r1)->value);
   memcpy(rec1+4,  ((ncmed_rec *)r1)->date2+6, 4);
   memcpy(rec1+8,  ((ncmed_rec *)r1)->date2+3, 2);
   memcpy(rec1+10, ((ncmed_rec *)r1)->date2,   2);
   snprintf(rec2, sizeof(rec2), "%04X", ((ncmed_rec *)r2)->value);
   memcpy(rec2+4,  ((ncmed_rec *)r2)->date2+6, 4);
   memcpy(rec2+8,  ((ncmed_rec *)r2)->date2+3, 2);
   memcpy(rec2+10, ((ncmed_rec *)r2)->date2,   2);
   rec1[12] = rec2[12] = 0;
   return strcmp(rec2, rec1);
}

static int32_t nagra2_card_info(struct s_reader *reader)
{
	int32_t i;
	char currdate[11], tmp[64];
	struct nagra_data *csystem_data = reader->csystem_data;
	rdr_log(reader, "ROM:    %c %c %c %c %c %c %c %c", reader->rom[0], reader->rom[1], reader->rom[2],reader->rom[3], reader->rom[4], reader->rom[5], reader->rom[6], reader->rom[7]);
	rdr_log(reader, "REV:    %c %c %c %c %c %c", reader->rom[9], reader->rom[10], reader->rom[11], reader->rom[12], reader->rom[13], reader->rom[14]);
	rdr_log_sensitive(reader, "SER:    {%s}", cs_hexdump(1, reader->hexserial+2, 4, tmp, sizeof(tmp)));
	rdr_log(reader, "CAID:   %04X",reader->caid);
	rdr_log(reader, "Prv.ID: %s(sysid)",cs_hexdump(1, reader->prid[0], 4, tmp, sizeof(tmp)));
	for (i=1; i<reader->nprov; i++)
	{
    	rdr_log(reader, "Prv.ID: %s",cs_hexdump(1, reader->prid[i], 4, tmp, sizeof(tmp)));
	}
   // sky(oscam.smartcard)
	uint32_t ulserial;
	ulserial = b2i(4,reader->hexserial+2);
	sprintf(reader->ascserial, "%02d.%04d.%04d.??",
			  ulserial / 100000000,
			 (ulserial / 10000) % 10000,
			 (ulserial % 10000));

	cs_clear_entitlement(reader); //reset the entitlements
	if (csystem_data->is_tiger)
	{
	  	rdr_log(reader, "Activation Date : %s", nagra_datetime(reader, csystem_data->ActivationDate, 0, currdate, 0));
	  	rdr_log(reader, "Expiry Date : %s", nagra_datetime(reader, csystem_data->ExpiryDate, 0, currdate, &reader->card_valid_to));
	}
	if (reader->nagra_read && csystem_data->is_tiger && memcmp(reader->rom, "NCMED", 5) == 0)
	{
		ncmed_rec records[255];
		int32_t num_records = 0;
		uint8_t tier_cmd1[] = { 0x00, 0x00 };
		uint8_t tier_cmd2[] = { 0x01, 0x00 };
		def_resp;
		int32_t j;
		do_cmd(reader, 0xD0, 0x04, 0x50, 0x0A, tier_cmd1, cta_res, &cta_lr);
		if (cta_lr == 0x0C)
		{
			int32_t prepaid = 0;
			int32_t credit = 0;
			int32_t balance = 0;

			uint16_t credit_in  = cta_res[8] << 8 | cta_res[9];
			uint16_t credit_out = cta_res[5] << 8 | cta_res[6];
			balance = (credit_in - credit_out) / 100;

			for (i = 0; i < 13; ++i)
			{
				tier_cmd2[1] = i;
				do_cmd(reader, 0xD0, 0x04, 0x50, 0xAA, tier_cmd2, cta_res, &cta_lr);
				if (cta_lr == 0xAC)
				{
				//	rdr_log_dump(reader, cta_res, cta_lr, "NCMED Card Record %d", i+1);
					for (j = 2; j < cta_res[1] - 14; ++j)
					{
					   if (cta_res[j] == 0x80 && cta_res[j+6] != 0x00)
					   {
					      int32_t val_offs = 0;
					      nagra_datetime(reader, &cta_res[j+6], 0, records[num_records].date2, 0);

					      switch (cta_res[j+1])
					      {
					         case 0x00:
					         case 0x01:
					         case 0x20:
					         case 0x21:
					         case 0x29:
					            nagra_datetime(reader, &cta_res[j+8], 0, records[num_records].date1, 0);
					            val_offs = 1;
					            break;

					         case 0x80:
					            nagra_datetime(reader, &cta_res[j+6], 0, records[num_records].date1, 0);
					            val_offs = 1;
					            break;

					         default:
					            rdr_log(reader, "Unknown record : %s", cs_hexdump(1, &cta_res[j], 17, tmp, sizeof(tmp)));
					      }
					      if (val_offs > 0)
					      {
					         records[num_records].type = cta_res[j+1];
					         records[num_records].value = cta_res[j+4] << 8 | cta_res[j+5];
					         records[num_records++].price = cta_res[j+11] << 8 | cta_res[j+12];
					      }
					      j += 16;
				   	}
					}
		     	}
			}
			if (reader->nagra_read == 1)
			 	qsort(records, num_records, sizeof(ncmed_rec), reccmp);
			else
			 	qsort(records, num_records, sizeof(ncmed_rec), reccmp2);

			int32_t  euro=0;
			char tiername[83];
			time_t rawtime;
			struct tm timeinfo;
			time (&rawtime);
			localtime_r(&rawtime, &timeinfo);
			snprintf(currdate, sizeof(currdate), "%02d/%02d/%04d", timeinfo.tm_mday, timeinfo.tm_mon+1, timeinfo.tm_year+1900);

			for (i = 0; i < num_records; ++i)
			{
				switch (records[i].type)
				{
					case 0x00:
					case 0x01:
					   if (reccmp(records[i].date2,currdate) >= 0)
					   {
					      if (reader->nagra_read == 2)
					         rdr_log(reader, "Tier : %04X, expiry date: %s %s",
					                   records[i].value, records[i].date2, get_tiername(records[i].value, reader->caid, tiername));
					      else if (reader->nagra_read == 1)
					      {
					         euro = (records[i].price / 100);
					         rdr_log(reader, "Activation     : (%04X) from %s to %s  (%3d euro) %s",
					                   records[i].value, records[i].date1, records[i].date2, euro, get_tiername(records[i].value, reader->caid, tiername));
					      }
					      // sky(!)
					      cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
					   }
					   break;

					case 0x20:
					case 0x21:
					   if (reccmp(records[i].date2,currdate) >= 0)
					   {
					      if (reader->nagra_read == 2)
					      {
					         rdr_log(reader, "Tier : %04X, expiry date: %s %s",
					                   records[i].value, records[i].date2, get_tiername(records[i].value, reader->caid, tiername));
					      }
					      // sky(!)
					      cs_add_entitlement(reader, reader->caid, b2ll(4, reader->prid[0]), records[i].value, 0, tiger_date2time(records[i].date1), tiger_date2time(records[i].date2)+ 0x1517F, 4, NULL, 1);
					   }
					   break;
				}
				if (reader->nagra_read == 2)
				{
					while (i < num_records - 1 && records[i].value == records[i+1].value)
					   ++i;
				}
			}

			for (i = 0; i < num_records; ++i)
			{
				switch (records[i].type)
				{
					case 0x80:
					   if (reader->nagra_read == 1)
					   {
					     euro = (records[i].price / 100) - prepaid;
					     credit += euro;
					     prepaid += euro;
					     if (euro)
					       rdr_log(reader, "Recharge       :               %s                (%3d euro)",
					                 records[i].date2, euro);
					   }
					   break;

					case 0x20:
					case 0x21:
					   if (reader->nagra_read == 1)
					   {
					     euro = records[i].price / 100;
					     credit -= euro;
					     rdr_log(reader, "Subscription   : (%04X) from %s to %s  (%3d euro) %s",
					               records[i].value, records[i].date1, records[i].date2, euro, get_tiername(records[i].value, reader->caid, tiername));
					   }
					   break;

					case 0x29:
					   euro = records[i].price / 100;
					   if (reader->nagra_read == 1) credit -= euro;
					   rdr_log(reader, "Event purchase : (%04X) from %s to %s  (%3d euro)",
					             records[i].value, records[i].date1, records[i].date2, euro);
					   break;
				}
			}
			if (reader->nagra_read == 1)
				rdr_log(reader, "Credit         :                                          %3d euro", credit);
			else
				rdr_log(reader, "Credit : %3d euro", balance);
		}
	}
	else {
    	def_resp;
    	char tmp_dbg[13];
    	CamStateRequest(reader);
		if (!do_cmd(reader, 0x12,0x02,0x92,0x06,0,cta_res,&cta_lr))
		{
			rdr_log_dbg(reader, D_READER, "get serial failed");
			return ERROR;
		}
		memcpy(reader->hexserial+2, cta_res+2, 4);
		rdr_log_dbg_sensitive(reader, D_READER, "SER:  {%s}", cs_hexdump(1, reader->hexserial+2, 4, tmp_dbg, sizeof(tmp_dbg)));
		memcpy(reader->sa[0], cta_res+2, 2);
		reader->nprov = 1;
		if (!GetDataType(reader, IRDINFO,0x39)) return ERROR;
		rdr_log_dbg(reader, D_READER, "IRDINFO DONE");
		CamStateRequest(reader);

		if (!memcmp(reader->rom+5, "181", 3)==0) //dt05 is not supported by rom181
		{
			rdr_log(reader, "-----------------------------------------");
			rdr_log(reader, "|id  |tier    |valid from  |valid to    |");
		  	rdr_log(reader, "+----+--------+------------+------------+");
			if (!GetDataType(reader, TIERS,0x57)) return ERROR;
			rdr_log(reader, "-----------------------------------------");
			CamStateRequest(reader);
		}
	}
	rdr_log(reader, "ready for requests");
	return OK;
}

void nagra2_post_process(struct s_reader *reader)
{
	struct nagra_data *csystem_data = reader->csystem_data;
	if (!csystem_data->is_tiger)
	{
		CamStateRequest(reader);
		if RENEW_SESSIONKEY() NegotiateSessionKey(reader);
		if SENDDATETIME() DateTimeCMD(reader);
	}
}

static int32_t nagra2_do_ecm(struct s_reader *reader, const ECM_REQUEST *er, struct s_ecm_answer *ea)
{
	def_resp;
	struct nagra_data *csystem_data = reader->csystem_data;
	if (!csystem_data->is_tiger)
	{
		int32_t retry=0;
		if (csystem_data->is_n3_na) {
			unsigned char ecm_pkt[256+16];
			memset(ecm_pkt, 0, sizeof(ecm_pkt));
			memcpy(ecm_pkt, er->ecm+3+2, er->ecm[4]);

			while (!do_cmd(reader, er->ecm[3]+1,er->ecm[4]+5+2,0x88,0x04, ecm_pkt,cta_res,&cta_lr)) {
				if (retry == 0)
					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm (N3_NA) failed, retry");
				else {
					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm (N3_NA) failed, retry failed!");
					return ERROR;
				}
				retry++;
				cs_sleepms(10);
			}
		}
		else {
			if (reader->ecmcommand < 5) { // cache ecm commands until ecmcommand cache is full
				reader->ecmcommandcache[reader->ecmcommand] = er->ecm[3];
				reader->ecmcommand++;
				if (reader->ecmcommand == 5) { // cache is full, comparing!
					int32_t t = 0;
					int32_t matchfound = 0;
					reader->ecmcommand++; // No more caching of ecm commands, next ecms will be compared!
					while (t < 5) {
						if (reader->ecmcommandcache[t] == er->ecm[3]) matchfound++;
						t++;
					}
					if (matchfound != 5) {
						reader->ecmcommand = 0; // reset ecm filter, start a new auto filter attempt
						rdr_log_dbg(reader, D_READER, "Auto ecm command filter caid %04X failed!", reader->caid);
					}
					else {
						reader->ecmcommandcache[0] = er->ecm[3]; // Passed the filter, store the normal ecm command for this reader!
						rdr_log_dbg(reader, D_READER, "Auto ecm command filter caid %04X set to command %02X", reader->caid, er->ecm[3]);
					}
				}
			}
			else if (reader->ecmcommandcache[0] != er->ecm[3]) {
	         rdr_log_dbg(reader, D_READER, "Warning: received an abnominal ecm command %02X for caid: %04X, ignoring!", er->ecm[3], reader->caid);
	         memset(ea, 0, sizeof(struct s_ecm_answer)); // give it back 00000000 to not disturb the loadbalancer for valid ecm requests on this channel.
	         return OK;
         }
			myprintf("nagra:ecm send\n");
			while (!do_cmd(reader, er->ecm[3],er->ecm[4]+2,0x87,0x02, er->ecm+3+2,cta_res,&cta_lr))
			{
				if (retry == 0)
					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm failed, retry");
				else {
					rdr_log_dbg(reader, D_READER, "nagra2_do_ecm failed, retry failed!");
					return ERROR;
				}
				retry++;
				cs_sleepms(10);
			}
		}
		cs_sleepms(10);

		retry=0;
		while (!CamStateRequest(reader) && retry < 3)
		{
			rdr_log_dbg(reader, D_READER, "CamStateRequest failed, try: %d", retry);
			retry++;
			cs_sleepms(10);
		}
		myprintf("nagra:has_cw{%d}\n", HAS_CW());
		if (HAS_CW() && (do_cmd(reader, 0x1C,0x02,0x9C,0x36,NULL,cta_res,&cta_lr)))
		{
			unsigned char v[8];
			memset(v,0,sizeof(v));
			idea_cbc_encrypt(&cta_res[30],ea->cw,  8,&csystem_data->ksSession,v,IDEA_DECRYPT);
			memset(v,0,sizeof(v));
			idea_cbc_encrypt(&cta_res[ 4],ea->cw+8,8,&csystem_data->ksSession,v,IDEA_DECRYPT);
			if (csystem_data->swapCW==1)
		  	{
		  		rdr_log_dbg(reader, D_READER, "swap cws");
	    		unsigned char tt[8];
	    		memcpy(&tt[0],&ea->cw[0],8);
	    		memcpy(&ea->cw[0],&ea->cw[8],8);
	   		memcpy(&ea->cw[8],&tt[0],8);
	    	}
			return OK;
		}
	}
	else
	{
		//check ECM prov id
		if (memcmp(&reader->prid[0][2], er->ecm+5, 2))
			return ERROR;

		//                  ecm_data: 80 30 89 D3 87 54 11 10 DA A6 0F 4B 92 05 34 00 ...
		//serial_data: A0 CA 00 00 8C D3 8A 00 00 00 00 00 10 DA A6 0F .
		unsigned char ecm_trim[150];
		memset(ecm_trim, 0, 150);
		memcpy(&ecm_trim[5], er->ecm+3+2+2, er->ecm[4]+2);
		if (do_cmd(reader, er->ecm[3],er->ecm[4]+5,0x53,0x16, ecm_trim,cta_res,&cta_lr))
		{
			if (cta_res[2] == 0x01)
			{

				unsigned char v[8];
				memset(v,0,sizeof(v));
				idea_cbc_encrypt(&cta_res[14],ea->cw,  8,&csystem_data->ksSession,v,IDEA_DECRYPT);
				memset(v,0,sizeof(v));
				idea_cbc_encrypt(&cta_res[ 6],ea->cw+8,8,&csystem_data->ksSession,v,IDEA_DECRYPT);
				return OK;
			}
			rdr_log_dbg(reader, D_READER, "can't decode ecm");
			return ERROR;
		}
	}
	return ERROR;
}

int32_t nagra2_get_emm_type(EMM_PACKET *ep, struct s_reader * rdr) //returns 1 if shared emm matches SA, unique emm matches serial, or global or unknown
{
	switch (ep->emm[0]) {
		case 0x83:
			memset(ep->hexserial,0,8);
			ep->hexserial[0] = ep->emm[5];
			ep->hexserial[1] = ep->emm[4];
			ep->hexserial[2] = ep->emm[3];
			if (ep->emm[7] == 0x10) {
				ep->type = SHARED;
				return (!memcmp (rdr->hexserial+2, ep->hexserial, 3));
			}
			else {
				ep->hexserial[3] = ep->emm[6];
				ep->type = UNIQUE;
				return (!memcmp (rdr->hexserial+2, ep->hexserial, 4));
			}
		case 0x82:
			ep->type = GLOBAL;
			return 1;
		default:
			ep->type = UNKNOWN;
			return 1;
	}
}

static int32_t nagra2_get_emm_filter(struct s_reader *rdr, struct s_csystem_emm_filter** emm_filters, unsigned int* filter_count)
{
	if (*emm_filters == NULL) {
		const unsigned int max_filter_count = 3;
		if (!cs_malloc(emm_filters, max_filter_count * sizeof(struct s_csystem_emm_filter)))
		  	return ERROR;

		struct s_csystem_emm_filter *filters = *emm_filters;
		*filter_count = 0;

		int32_t idx = 0;

		filters[idx].type = EMM_GLOBAL;
		filters[idx].enabled   = 1;
		filters[idx].filter[0] = 0x82;
		filters[idx].mask[0]   = 0xFF;
		idx++;

		filters[idx].type = EMM_SHARED;
		filters[idx].enabled   = 1;
		filters[idx].filter[0] = 0x83;
		filters[idx].filter[1] = rdr->hexserial[4];
		filters[idx].filter[2] = rdr->hexserial[3];
		filters[idx].filter[3] = rdr->hexserial[2];
		filters[idx].filter[4] = 0x00;
		filters[idx].filter[5] = 0x10;
		memset(&filters[idx].mask[0], 0xFF, 6);
		idx++;

		filters[idx].type = EMM_UNIQUE;
		filters[idx].enabled   = 1;
		filters[idx].filter[0] = 0x83;
		filters[idx].filter[1] = rdr->hexserial[4];
		filters[idx].filter[2] = rdr->hexserial[3];
		filters[idx].filter[3] = rdr->hexserial[2];
		filters[idx].filter[4] = rdr->hexserial[5];
		filters[idx].filter[5] = 0x00;
		memset(&filters[idx].mask[0], 0xFF, 6);
		idx++;

		*filter_count = idx;
	}

	return OK;
}

static int32_t nagra2_do_emm(struct s_reader *reader, EMM_PACKET *ep)
{
	def_resp;
	struct nagra_data *csystem_data = reader->csystem_data;
	if (!csystem_data->is_tiger)
	{
		if (!do_cmd(reader, ep->emm[8],ep->emm[9]+2,0x84,0x02,ep->emm+8+2,cta_res,&cta_lr))
		{
			rdr_log_dbg(reader, D_READER, "nagra2_do_emm failed");
			return ERROR;
		}
		// for slow t14 nagra cards, we must do additional timeout
		if (csystem_data->is_pure_nagra==1)
		{
			cs_sleepms(300);
		}
		cs_sleepms(250);
		nagra2_post_process(reader);
	}
	else
	{
		//check EMM prov id
		if (memcmp(&reader->prid[0][2], ep->emm+10, 2))
		{
			rdr_log_dbg(reader, D_READER, "EMM skipped since provider doesnt match!");
			return SKIPPED;
		}
		//   emm_data: 82 70 8E 00 00 00 00 00 D3 87 8D 11 C0 F4 B1 27 2C 3D 25 94 ...
		//serial_data: A0 CA 00 00 8C D3 8A 01 00 00 00 00 C0 F4 B1 27 2C 3D 25 94 ...
		unsigned char emm_trim[150] = { 0x01, 0x00, 0x00, 0x00, 0x00 };
		memcpy(&emm_trim[5], ep->emm+3+5+2+2, ep->emm[9]+2);
		if (!do_cmd(reader, ep->emm[8],ep->emm[9]+5,0x53,0x16, emm_trim,cta_res,&cta_lr))
		{
			rdr_log_dbg(reader, D_READER, "nagra2_do_emm failed");
			return ERROR;
		}
		cs_sleepms(300);
	}
	if (ep->type != GLOBAL)
	{
		struct timeb now;
		cs_ftime(&now);
		int64_t gone = comp_timeb(&now, &reader->emm_last);
		if (gone > 3600*1000)
		{
			add_job(reader->client, ACTION_READER_CARDINFO, NULL, 0); // refresh entitlement since it might have been changed!
		}
	}
	return OK;
}

const struct s_cardsystem reader_nagra =
{
	.desc           = "nagra",
	.caids          = (uint16_t[]){ 0x18, 0 },
	.do_emm         = nagra2_do_emm,
	.do_ecm         = nagra2_do_ecm,
	.post_process   = nagra2_post_process,
	.card_info      = nagra2_card_info,
	.card_init      = nagra2_card_init,
	.get_emm_type   = nagra2_get_emm_type,
	.get_emm_filter = nagra2_get_emm_filter,
};

#endif
